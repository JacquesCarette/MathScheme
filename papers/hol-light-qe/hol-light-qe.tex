\documentclass[fleqn]{llncs}
\usepackage{latexsym}
\usepackage{amssymb,amsmath}
\usepackage{stmaryrd}
\usepackage{graphicx}
%\usepackage{color}
\usepackage{hyperref}
\usepackage{phonetic}
\usepackage{xargs}
\usepackage[pdftex,dvipsnames]{xcolor}
\usepackage{listings}

\lstset{language=ml,basicstyle=\ttfamily,breaklines=true,showspaces=false,showstringspaces=false,breakatwhitespace=true,texcl=true,escapeinside={(*}{*)}}

\input{hol-light-qe-def}

\usepackage[colorinlistoftodos,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}

\title{{\HLQE}\info{Changed HOL Light from sc to rm as used by J. Harrison.}\thanks{This research was supported by NSERC.}}

\author{Jacques Carette, William M. Farmer, and Patrick Laskowski}

\institute{%
Computing and Software, McMaster University, Canada\\
\url{http://www.cas.mcmaster.ca/~carette}\\
\url{http://imps.mcmaster.ca/wmfarmer}\\[1.5ex]
25 January 2018
}

\pagestyle{headings}

\begin{document}

\maketitle

\begin{abstract}
We are interested in algorithms that manipulate mathematical
expressions in mathematically meaningful ways. Expressions are
syntactic, but most logics do not allow one to discuss syntax.
{\churchqe} is a version of Church's type theory that includes
quotation and evaluation operators that are similar to quote and eval
in the Lisp programming language.  Since the {\HOL} logic is also a
version of Church's type theory, we decided to add quotation and
evaluation to {\HL} to demonstrate the implementability of {\churchqe}
and the benefits of having quotation and evaluation in a proof
assistant.  The resulting system is called {\HLQE}.  Here we document
the design of {\HLQE} and the challenges that needed to be overcome.
\end{abstract}

\iffalse 

\textbf{Keywords:} Church's type theory, proof assistants, quotation
and evaluation, symbolic computation, reasoning about syntax, biform
theories.

\fi

\section{Introduction}\label{sec:introduction}

A \emph{syntax-based mathematical algorithm (SBMA)} manipulates
mathematical expressions in a mathematically meaningful way.  SBMAs
are commonplace in mathematics.  Examples include algorithms that
compute arithmetic operations by manipulating numerals, linear
transformations by manipulating matrices, and derivatives by
manipulating functional expressions.  Reasoning about the mathematical
meaning of an SBMA requires reasoning about the relationship between
how the expressions are manipulated by the SBMA and what the
manipulations mean mathematically.

We argue in~\cite{Farmer13} that the combination of quotation and
evaluation, along with some inference rules, provides the means to
reason about the interplay between syntax and semantics, which is what
is needed for reasoning about SBMAs.  \emph{Quotation} is an operation
that maps an expression $e$ to a special value called a
\emph{syntactic value} that represents the syntax tree of $e$.
Quotation enables expressions to be manipulated as syntactic entities.
\emph{Evaluation} is an operation that maps a syntactic value $s$ to
the value of the expression that is represented by $s$.  Evaluation
enables meta-level reasoning via syntactic values to be reflected into
object-level reasoning.  Quotation and evaluation thus form an
infrastructure for integrating meta-level and object-level
reasoning. Quotation gives a form of \emph{reification} of
object-level values which allows introspection.  Along with inference
rules, this gives a certain amount of {\emph{logical
  reflection}}\improvement{Reference?}. Evaluation adds to this some
aspects of {\emph{computational reflection}}\improvement{Reference?}.

Incorporating quotation and evaluation operators --- like quote and
eval in the Lisp programming language --- into a traditional logic
like first-order logic or simple type theory is not a straightforward
task.  Several challenging design problems stand in the way.  The
three design problems that most concern us are the following.  We will
write the quotation and evaluation operators applied to an expression
$e$ as $\synbrack{e}$ and $\sembrack{e}$, respectively.

\be

  \item \emph{Evaluation Problem.}  An evaluation operator is
    applicable to syntactic values that represent formulas and thus is
    effectively a truth predicate.  Hence, by the proof of Alfred
    Tarski's theorem on the undefinability of truth~\cite{Tarski35a},
    if the evaluation operator is total in the context of a
    sufficiently strong theory like first-order Peano arithmetic, then
    it is possible to express the liar paradox using the quotation and
    evaluation operators.  Therefore, the evaluation operator must be
    partial and the law of disquotation cannot hold universally (i.e.,
    for some expressions $e$, $\sembrack{\synbrack{e}} \not= e$).  As
    a result, reasoning with evaluation can be cumbersome and leads to
    undefined expressions.

  \item \emph{Variable Problem.}  The variable $x$ is not free in the
    expression $\synbrack{x + 3}$ (or in any quotation).  However, $x$
    is free in $\sembrack{\synbrack{x + 3}}$ because
    $\sembrack{\synbrack{x + 3}} = x + 3$.  If the value of a constant
    $c$ is $\synbrack{x + 3}$, then $x$ is free in $\sembrack{c}$
    because $\sembrack{c} = \sembrack{\synbrack{x + 3}} = x + 3$.
    Hence, in the presence of an evaluation operator, whether or not a
    variable is free in an expression may depend on the values of the
    expression's components.  As a consequence, the substitution of an
    expression for the free occurrences of a variable in another
    expression depends on the semantics (as well as the syntax) of the
    expressions involved and must be integrated with the proof system
    for the logic.  That is, a logic with quotation and evaluation
    requires a semantics-dependent form of substitution in which side
    conditions, like whether a variable is free in an expression, are
    proved within the proof system.  This is a major departure from
    traditional logic.

  \item \emph{Double Substitution Problem.}  By the semantics of
    evaluation, the value of $\sembrack{e}$ is the \emph{value} of the
    expression whose syntax tree is represented by the \emph{value} of
    $e$.  Hence the semantics of evaluation involves a double
    valuation.  This is most apparent when the value of a variable
    involves a syntax tree which refers to the name of that same
    variable. For example, if
    the value of a variable $x$ is $\synbrack{x}$, then
    $\sembrack{x} = \sembrack{\synbrack{x}} = x = \synbrack{x}$.
    Hence the substitution of $\synbrack{x}$ for $x$ in $\sembrack{x}$
    requires one substitution inside the argument of the evaluation
    operator and another substitution after the evaluation operator is
    eliminated.  This double substitution is another major departure
    from traditional logic.

\ee

{\churchqe}~\cite{FarmerArxiv16,Farmer16} is version of Church's type
theory~\cite{Church40} with quotation and evaluation that solves these
three design problems.  It is based on {\qzero}~\cite{Andrews02},
Peter Andrews' version of Church's type theory.  We believe
{\churchqe} is the first readily implementable version of simple type
theory that includes \emph{global} quotation and evaluation operators.  We
show in~\cite{FarmerArxiv16} that it is suitable for defining,
applying, and reasoning about SBMAs.

To demonstrate that {\churchqe} is indeed implementable, we have
implemented {\churchqe} by modifying \HL~\cite{Harrison09}, a
compact implementation of the HOL logic~\cite{GordonMelham93}.  The
resulting version of \HL{} is called \HLQE.  Here we present its
design, implementation, and the challenges to doing so.

The rest of the paper is organized as follows.
Section~\ref{sec:ctt-qe} presents the key ideas underlying {\churchqe}
and explains how {\churchqe} solves the three design problems given
above.  Section~\ref{sec:hol-light} offers a brief overview of HOL
Light.  The \HLQE{} implementation is described in
section~\ref{sec:implementation}, and examples of how quotation and
evaluation are used in it are discussed in section~\ref{sec:examples}.
Section~\ref{sec:related-work} is devoted to related work.  And the
paper ends with some final remarks in section~\ref{sec:conclusion}
including a brief discussion on future work.

\section{\churchqe}\label{sec:ctt-qe}

The syntax and semantics of {\churchqe} as well as the proof system
for {\churchqe} are defined in~\cite{FarmerArxiv16}.  In this section
we will only introduce the definitions and results of {\churchqe} that
are key to understanding how \HLQE{} implements {\churchqe}.  The
reader is encouraged to consult~\cite{FarmerArxiv16} when additional
details are required.

\subsection{Syntax}

The syntax of {\churchqe} has the same machinery as {\qzero} plus an
inductive type $\epsilon$ of syntactic values, a partial quotation
operator, and a typed evaluation operator.

A \emph{type} of {\churchqe} is defined inductively by the following
formation rules:
%
\be

  \item \emph{Type of individuals}: $\iota$ is a type.

  \item \emph{Type of truth values}: $\omicron$ is a type.

  \item \emph{Type of constructions}: $\epsilon$ is a type.

  \item \emph{Function type}: If $\alpha$ and $\beta$ are types, then
    $(\alpha \tarrow \beta)$ is a type.

\ee

\noindent
Let $\sT$ denote the set of types of {\churchqe}.  

A \emph{typed symbol} is a symbol with a subscript from $\sT$.  Let
$\sV$ be a set of typed symbols such that, for each $\alpha \in \sT$,
$\sV$ contains denumerably many typed symbols with subscript~$\alpha$.
A \emph{variable of type $\alpha$} of {\churchqe} is a member of $\sV$
with subscript~$\alpha$.  $\textbf{x}_\alpha, \textbf{y}_\alpha,
\textbf{z}_\alpha, \ldots$ are syntactic variables ranging over
variables of type $\alpha$. Let $\sC$ be a set of typed symbols
disjoint from $\sV$.  A \emph{constant of type $\alpha$} of
{\churchqe} is a member of $\sC$ with subscript~$\alpha$.
$\textbf{c}_\alpha, \textbf{d}_\alpha, \ldots$ are syntactic variables
ranging over constants of type~$\alpha$.  $\sC$ contains a set of
\emph{logical constants} that include $\mname{app}_{\epsilon \tarrow
  \epsilon \tarrow \epsilon}$, $\mname{abs}_{\epsilon \tarrow \epsilon
  \tarrow \epsilon}$, and $\mname{quo}_{\epsilon \tarrow \epsilon}$.

An \emph{expression of type $\alpha$} of {\churchqe} is defined
inductively by the formation rules below.  $\textbf{A}_\alpha,
\textbf{B}_\alpha, \textbf{C}_\alpha, \ldots$ are syntactic variables
ranging over expressions of type $\alpha$.  An expression is
\emph{eval-free} if it is constructed using just the first five
formation rules.
%
\be

  \item \emph{Variable}: $\textbf{x}_\alpha$ is an expression of type
    $\alpha$.

  \item \emph{Constant}: $\textbf{c}_\alpha$ is an expression of type
    $\alpha$.

  \item \emph{Function application}: $(\textbf{F}_{\alpha \tarrow
    \beta} \, \textbf{A}_\alpha)$ is an expression of type $\beta$.

  \item \emph{Function abstraction}: $(\LambdaApp \textbf{x}_\alpha
    \mdot \textbf{B}_\beta)$ is an expression of type $\alpha \tarrow
    \beta$.

  \item \emph{Quotation}: $\synbrack{\textbf{A}_\alpha}$ is an
    expression of type $\epsilon$ if $\textbf{A}_\alpha$ is eval-free.

  \item \emph{Evaluation}: $\sembrack{\textbf{A}_\epsilon}_{{\bf
      B}_\beta}$ is an expression of type $\beta$.

\ee 

\noindent
The sole purpose of the second component $\textbf{B}_\beta$ in an
evaluation $\sembrack{\textbf{A}_\epsilon}_{{\bf B}_\beta}$ is to
establish the type of the evaluation; we will thus write
$\sembrack{\textbf{A}_\epsilon}_{{\bf B}_\beta}$ as
$\sembrack{\textbf{A}_\epsilon}_\beta$.

A \emph{construction} of {\churchqe} is an expression of type
$\epsilon$ defined inductively as follows:

\be

  \item $\synbrack{\textbf{x}_\alpha}$ is a construction.

  \item $\synbrack{\textbf{c}_\alpha}$ is a construction.

  \item If $\textbf{A}_\epsilon$ and $\textbf{B}_\epsilon$ are
    constructions, then $\mname{app}_{\epsilon \tarrow \epsilon
      \tarrow \epsilon} \, \textbf{A}_\epsilon \,
    \textbf{B}_\epsilon$, $\mname{abs}_{\epsilon \tarrow \epsilon
      \tarrow \epsilon} \, \textbf{A}_\epsilon \,
    \textbf{B}_\epsilon$, and $\mname{quo}_{\epsilon \tarrow \epsilon}
    \, \textbf{A}_\epsilon$ are constructions.

\ee

\noindent
The set of constructions is thus an inductive type whose base elements
are quotations of variables and constants and whose constructors are
$\mname{app}_{\epsilon \tarrow \epsilon \tarrow \epsilon}$,
$\mname{abs}_{\epsilon \tarrow \epsilon \tarrow \epsilon}$, and
$\mname{quo}_{\epsilon \tarrow \epsilon}$.  As we will see shortly,
constructions serve as syntactic values.

{Let $\sE$ be the function mapping eval-free expressions to
constructions that is defined inductively as follows:}
\unsure{The definition below seems trivial, it just maps from
one syntax to another. On the flip-side, if a reader is expecting
a $\lambda$-calculus, then $\sE$ in the \mname{app} case is ill-defined
as you can't pattern match on an application.}

\be

  \item $\sE(\textbf{x}_\alpha) = \synbrack{\textbf{x}_\alpha}$.

  \item $\sE(\textbf{c}_\alpha) = \synbrack{\textbf{c}_\alpha}$.

  \item $\sE(\textbf{F}_{\alpha \tarrow \beta} \, \textbf{A}_\alpha) =
    \mname{app}_{\epsilon \tarrow \epsilon \tarrow \epsilon} \,
    \sE(\textbf{F}_{\alpha \tarrow \beta}) \, \sE(\textbf{A}_\alpha)$.

  \item $\sE(\LambdaApp \textbf{x}_\alpha \mdot \textbf{B}_\beta) =
    \mname{abs}_{\epsilon \tarrow \epsilon \tarrow \epsilon} \,
    \sE(\textbf{x}_\alpha) \, \sE(\textbf{B}_\beta)$.

  \item $\sE(\synbrack{\textbf{A}_\alpha}) = \mname{quo}_{\epsilon
    \tarrow \epsilon} \, \sE(\textbf{A}_\alpha)$.

\ee

\noindent
When $\textbf{A}_\alpha$ is eval-free, $\sE(\textbf{A}_\alpha)$ is the
unique construction that represents the syntax tree of
$\textbf{A}_\alpha$.  That is, $\sE(\textbf{A}_\alpha)$ is a syntactic
value that represents how $\textbf{A}_\alpha$ is syntactically
constructed.  For every eval-free expression, there is a construction
that represents its syntax tree, but not every construction represents
the syntax tree of an eval-free expression.  For example,
$\mname{app}_{\epsilon \tarrow \epsilon \tarrow \epsilon} \,
\synbrack{\textbf{x}_\alpha} \, \synbrack{\textbf{x}_\alpha}$
represents the syntax tree of $(\textbf{x}_\alpha \,
\textbf{x}_\alpha)$ which is not an expression of {\churchqe} since
the types are mismatched.  A construction is \emph{proper} if it is in
the range of $\sE$, i.e., it represents the syntax tree of an
eval-free expression.

The purpose of $\sE$ is to define the semantics of quotation: the
meaning of $\synbrack{\textbf{A}_\alpha}$ is $\sE(\textbf{A}_\alpha)$.

\subsection{Semantics}

The semantics of {\churchqe} is based on Henkin-style general
models~\cite{Henkin50}.  An expression $\textbf{A}_\epsilon$ of type
$\epsilon$ denotes a construction, and when $\textbf{A}_\epsilon$ is a
construction, it denotes itself.  The semantics of the quotation and
evaluation operators are defined so that the following theorems hold:

\begin{thm}[Law of Quotation] \label{thm:sem-quotation}
$\synbrack{\textbf{A}_\alpha} = \sE(\textbf{A}_\alpha)$ is valid in
  {\churchqe}.
\end{thm}

\begin{thm}[Law of Disquotation] \label{thm:sem-disquotation}
$\sembrack{\synbrack{\textbf{A}_\alpha}}_\alpha = \textbf{A}_\alpha$
  is valid in {\churchqe}.
\end{thm}

\todo{Some comments that $=$ is not up to $\alpha\beta$, otherwise
the Law of Quotation does not hold -- $\synbrack{2+3}$ is not the
same as $\sE(5)$.}

\subsection{Proof System}

The proof system for {\churchqe} consists of the axioms for {\qzero},
the single rule of inference for {\qzero}, and additional axioms that
extend the rules for beta-reduction, define the logical constants of
{\churchqe}, specify $\epsilon$ as an inductive type, and state the
properties of quotation and evaluation.  We prove
in~\cite{FarmerArxiv16} that this proof system is sound for all
formulas and complete for eval-free formulas.
\unsure{I think that some, if not most, of these rules should be
shown. They either need to be here or in the implementation section,
with a forward pointer.}

Substitution is performed in the proof system for {\churchqe} using
the properties of beta-reduction as Andrews does in the proof system
for {\qzero}~\cite[p.~213]{Andrews02}.  The syntactic notion of ``a
variable is free in an expression'' is replaced in Andrews'
beta-reduction axioms by the semantic notion of ``a variable is
effective in an expression'' when the expression is not necessarily
eval-free, and beta-reduction axioms for quotation and evaluation are
added to Andrews' beta-reduction axioms.  ``$\textbf{x}_\alpha$ is
effective in $\textbf{B}_\beta$'' means the value of
$\textbf{B}_\beta$ depends on the value of $\textbf{x}_\alpha$.
Clearly, if $\textbf{B}_\beta$ is eval-free, ``$\textbf{x}_\alpha$ is
effective in $\textbf{B}_\beta$'' implies ``$\textbf{x}_\alpha$ is
free in $\textbf{B}_\beta$''.  However, ``$\textbf{x}_\alpha$ is
effective in ${B}_\beta$'' is a refinement of ``$\textbf{x}_\alpha$ is
free in $\textbf{B}_\beta$'' on eval-free expressions since
$\textbf{x}_\alpha$ is free in $\textbf{x}_\alpha =
\textbf{x}_\alpha$, but $\textbf{x}_\alpha$ is not effective in
$\textbf{x}_\alpha = \textbf{x}_\alpha$.
\unsure{Because substitution is so important, I think more will be
needed -- in the same vein as above.}

\subsection{Design Problems} 

{\churchqe} solves the three design problems given in
section~\ref{sec:introduction}.  The Evaluation Problem is completely
avoided by restricting the quotation operator to eval-free expressions
and thus making it impossible to express the liar paradox.  The
Variable Problem is overcome by modifying Andrews' beta-reduction
axioms as described above.  The Double Substitution Problem is eluded
by using a beta-reduction axiom for evaluations that excludes
beta-reductions that embody a double substitution.

\section{\HL}\label{sec:hol-light}

\HL~\cite{Harrison09} is an open-source proof assistant developed by
John Harrison.  It implements a logic (HOL) which is a version of
Church's type theory.  It is a simple implementation of the HOL proof
assistant~\cite{GordonMelham93} written in OCaml and hosted on GitHub
at \url{https://github.com/jrh13/hol-light/}.  Although it is a
relatively small system, it has been used to formalize many kinds of
mathematics and to check many proofs including the lion's share of Tom
Hale's proof of the Kepler conjecture~\cite{HalesEtAl17}.

\HL{} is very well suited to serve as a foundation on which to build
an implementation of {\churchqe}: First, it is an open-source system
that can be freely modified as long as certain very minimal conditions
are satisfied.  Second, it is an implementation of a version of simple
type theory that is essentially {\qzero}, the version of Church's type
theory underlying {\churchqe}, plus (1) polymorphic type variables,
(2) an axiom of choice expressed by asserting that the Hilbert
$\epsilon$ operator is a choice (indefinite description) operator, and
(3) an axiom of infinity that asserts that \texttt{ind}, the type of
individuals, is infinite~\cite{Harrison09}.  The type variables in the
implemented logic are not a hindrance; they actually facilitate the
implementation of {\churchqe}.  The presence of the axioms of choice
and infinity in {\HL} alter the semantics of {\churchqe} without
compromising in any way the semantics of quotation and evaluation.
And third, \HL{} supports the definition of inductive types so that
$\epsilon$ can be straightforwardly defined.

\section{Implementation}\label{sec:implementation}

\subsection{Overview}

{\HLQE} was implemented in four stages:

\be

  \item The set of {\HL} terms was extended so that {\churchqe}
    expressions could be mapped to {\HL} terms.  This required the
    introduction of $\epsilon$, the type of construction, and term
    constructors for quotations and evaluations.  See
    subsection~\ref{subsec:mapping}.

  \item The {\HL} proof system was modified to include the machinery
    in {\churchqe} for reasoning about quotations and evaluations.
    This required adding new rules of inference to {\HL} and modifying
    the {\HL} \texttt{INST} rule of inference that simultaneously
    substitutes terms $t_1,\ldots,t_n$ for the free variables
    $x_1,\ldots,x_n$ in a sequent.  See
    subsection~\ref{subsec:proof-system}.

  \item Machinery, consisting of {\HOL} functions definitions,
    tactics, and theorems, was created for supporting reasoning about
    quotations and evaluations in the new system.  See
    subsection~\ref{subsec:machinery}.

  \item Examples were developed in the new system to test the
    implementation and to demonstrate the benefits of having quotation
    and evaluation in higher-order logic.  See section~\ref{sec:examples}.

\ee

\noindent
The first and second stages have been essentially completed; both
stages involved modifying the kernel of {\HL}.  The third and fourth
stages are ongoing; they did not include any changes to the {\HL}
kernel.

The {\HLQE} system was developed by the third author under the
supervision of the first two authors on an undergraduate NSERC USRA
research project at McMaster University.  {\HLQE} is available at
\[\mbox{\url{https://github.com/JacquesCarette/hol-light}},\]

\subsection{Mapping of {\churchqe} Expressions to {\HOL} Terms}\label{subsec:mapping}

Tables~\ref{tab:types} and~\ref{tab:expressions} illustrates how the
{\churchqe} types and expressions are mapped to the {\HOL} types and
terms, respectively.  The {\HOL} types and terms are written in the
the internal representation form employed in {\HLQE}.  The type
\texttt{epsilon} and the term constructors \texttt{Quote} and
\texttt{Eval} are additions to {\HL} explained below.  Since
{\churchqe} does not have type variables, there is a logical constant
$\mname{=}_{\alpha \tarrow \alpha \tarrow o}$ representing equality
for each $\alpha \in \sT$.  The members of this family of constants
are all mapped to a single {\HOL} constant with the polymorphic type
\texttt{a\_ty\_var->a\_ty\_var->bool} where \texttt{a\_ty\_var} is any
chosen {\HOL} type variable.  

The other logical constants of {\churchqe}~\cite[Table 1]{FarmerArxiv16}
are not mapped to primitive {\HOL} constants.  $\mname{app}_{\epsilon
  \tarrow \epsilon \tarrow \epsilon}$, $\mname{abs}_{\epsilon \tarrow
  \epsilon \tarrow \epsilon}$, and $\mname{quo}_{\epsilon \tarrow
  \epsilon}$ are implemented by \texttt{App}, \texttt{Abs}, and
\texttt{Quo}, constructors for the inductive type \texttt{epsilon}
given below.  The remaining logical constants are predicates on
constructions that are implemented by {\HOL} functions.

\begin{table}
\bc
\begin{tabular}{|lll|}
\hline
\textbf{${\bf CTT_{qe}}$ Type $\alpha$} \hspace*{2ex}
  & \textbf{HOL Type $\mu(\alpha)$}
  & \textbf{Abbreviation for $\mu(\alpha)$}\\
$\omicron$ & \texttt{Tyapp("bool",[])} & \texttt{bool}\\
$\iota$ & \texttt{Tyapp("ind",[])} & \texttt{ind}\\
$\epsilon$ & \texttt{Tyapp("epsilon",[])} & \texttt{epsilon}\\
$\beta \tarrow \gamma$ 
  & \texttt{Tyapp("fun",[\mbox{$\mu(\beta),\mu(\gamma)$}])} \hspace*{2ex}
  & \texttt{\mbox{$\mu(\beta)$}->\mbox{$\mu(\gamma)$}}\\  
\hline
\end{tabular}
\ec
\caption{Mapping of {\churchqe} Types to {\HOL} Types}\label{tab:types} 
\end{table}

\begin{table}
\bc
\begin{tabular}{|ll|}
\hline
\textbf{${\bf CTT_{qe}}$ Expression $e$} \hspace*{2ex}
  & \textbf{HOL Term $\nu(e)$}\\
$\textbf{x}_\alpha$
  & \texttt{Var("x",\mbox{$\mu(\alpha)$})}\\
$\textbf{c}_\alpha$
  & \texttt{Const("c",\mbox{$\mu(\alpha)$})}\\
$\mname{=}_{\alpha \tarrow \alpha \tarrow o}$
  & \texttt{Const("=",\texttt{a\_ty\_var->a\_ty\_var->bool})}\\
$(\textbf{F}_{\alpha \tarrow \beta} \, \textbf{A}_\alpha)$
  & \texttt{Comb(\mbox{\rm $\nu(\textbf{F}_{\alpha \tarrow \beta}),\nu(\textbf{A}_\alpha)$})}\\
$(\LambdaApp \textbf{x}_\alpha \mdot \textbf{B}_\beta)$
  & \texttt{Abs(Var("x",\mbox{$\mu(\alpha)$}),\mbox{\rm $\nu(\textbf{B}_\beta)$})}\\
$\synbrack{\textbf{A}_\alpha}$
  & \texttt{Quote(\mbox{\rm $\nu(\textbf{A}_\alpha),\mu(\alpha)$})}\\
$\sembrack{\textbf{A}_\epsilon}_{{\bf B}_\beta}$
  & \texttt{Eval(\mbox{\rm $\nu(\textbf{A}_\epsilon),\mu(\beta)$})}\\
\hline
\end{tabular}
\ec
\caption{Mapping of {\churchqe} Expressions to {\HOL} Terms}\label{tab:expressions} 
\end{table}

The {\churchqe} type $\epsilon$ is the type of constructions, the
syntactic values constructions that represent the syntax trees of
eval-free expressions.  $\epsilon$ is defined as an inductive type
\texttt{epsilon} in {\HLQE}.  The following inductive types
\texttt{type} and \texttt{epsilon} are defined in {\HLQE}:

\begin{lstlisting}
define_type "type = TyVar string
                  | TyBase string
                  | TyMonoCons string type
                  | TyBiCons string type type";;

define_type "epsilon = QuoVar string type 
                     | QuoConst string type
                     | App epsilon epsilon
                     | Abs epsilon epsilon
                     | Quo epsilon";;
\end{lstlisting}

Terms of type \texttt{type} denote the syntax trees of {\HLQE} types
(which are the same as {\HOL} types).  The terms of type
\texttt{epsilon} denote the syntax trees of {\HLQE} terms that are
eval-free (i.e., do not contain evaluations).  

The OCaml type of {\HOL} types in {\HLQE}

\begin{lstlisting}
type hol_type = Tyvar of string
              | Tyapp of string *  hol_type list
\end{lstlisting}

\noindent
is the same as in {\HL}, but the OCaml type of {\HOL} types in {\HLQE}

\begin{lstlisting}
type term = Var of string * hol_type
          | Const of string * hol_type
          | Comb of term * term
          | Abs of term * term
          | Quote of term * hol_type
          | Hole of term * hol_type
          | Eval of term * hol_type
\end{lstlisting}

\noindent
has three new constructors --- \texttt{Quote}, \texttt{Hole}, and
\texttt{Eval} --- that are not in {\HL}.

\texttt{Quote} constructs a quotation of type \texttt{epsilon} with
components $t$ and $\alpha$ from a term $t$ of type $\alpha$ that is
is eval-free.  \texttt{Eval} constructs an evaluation of type $\alpha$
with components $t$ and $\alpha$ from a term $t$ of type
\texttt{epsilon} and a type $\alpha$.  \texttt{Hole} is used to
construct ``holes'' of type \texttt{epsilon} in an quasiquotation as
described in~\cite{FarmerArxiv16}.  A {\HLQE} quotation that contains
holes is a quasiquotation, while a quotation without any holes is a
normal quotation.  The construction of terms in {\HLQE} has been
modified to allow a hole (of type \texttt{epsilon}) to be used where a
term of some other type is expected.

The external representation of a quotation \texttt{Quote(t,ty)} is
\texttt{Q\_ t \_Q}.  Similarly, the external representation of a hole
\texttt{Hole(t,ty)} is \texttt{H\_ t \_H}.  The external
representation of an evaluation \texttt{Quote(t,ty)} is \[\texttt{eval
  t to ty}.\]

\subsection{Modification of the {\HL} Proof System}\label{subsec:proof-system}

\subsection{Creation of Support Machinery}\label{subsec:machinery}

The {\HLQE} contains a number of {\HOL} functions, tactics, and
theorems that are useful for reasoning about constructions,
quotations, and evaluations.  An important example is the {\HOL}
function \texttt{isExprType} that implements the {\churchqe} family
of logical constants $\mname{is-expr}_{\epsilon \tarrow o}^{\alpha}$
where $\alpha$ ranges over members of $\sT$.  This function takes
terms $s_1$ and $s_1$ of type \texttt{epsilon} and \texttt{type},
respectively, and returns true iff $s_1$ represents
the syntax tree of a term $t$, $s_2$ represents the syntax tree of a
type $\alpha$, and $t$ is of type $\alpha$.


\section{Examples}\label{sec:examples}

\subsection{Law of Excluded Middle}

\subsection{Induction Schema}

\section{Related Work}\label{sec:related-work}

Quotation, evaluation, reflection, reification, issues of
intensionality versus extensionality, metaprogramming and
metareasoning each have extensive literature -- sometimes
in more than one field.  For example, one can find a
vast literature on reflection in logic, programming languages
and theorem proving. Due to space restrictions, we cannot
do justice to the full breadth of issues. For a full discussion,
please see the related work section in~\cite{FarmerArxiv17}.
The surveys of Costantini~\cite{Costantini02},
Harrison~\cite{Harrison95} are excellent. From a
programming perspective, the discussion and extensive 
bibliography of Kavvos' D.Phil. thesis~\cite{Kavvos2017}
are well worth reading.

Focusing just on interactive proof assistants, we find
that Robert Boyer and J Moore developed a global
infrastructure~\cite{BoyerMoore81}, for
incorporating symbolic algorithms into the Nqthm~\cite{BoyerMoore88}
theorem prover.  This approach is also used in
ACL2~\cite{KaufmannMoore97}, the successor to Nqthm;
see~\cite{HuntEtAl05}.  Over the last 30 years, the Nuprl group lead
by Robert Constable has produced a large body of work on metareasoning
and reflection for theorem
proving~\cite{AllenEtAl90,Barzilay05,Constable95,Howe92,KnoblockConstable86,Nogin05,Yu07}
that has been implemented in the Nuprl~\cite{Constable86} and
MetaPRL~\cite{HickeyEtAl03} systems.  Proof by reflection has become a
mainstream technique in the Coq~\cite{Coq8.5} proof assistant with the
development of tactics based on symbolic computations like the Coq
ring tactic~\cite{Boutin97,GregoireMahboubi05} and the formalizations
of the \emph{four color theorem}~\cite{Gonthier08} and the
\emph{Feit-Thompson odd-order theorem}~\cite{GonthierEtAl13} led by
Georges Gonthier.
See~\cite{Boutin97,BraibantPous11,Chlipala13,GonthierEtAl15,GregoireMahboubi05,JamesHinze09,OostdijkGeuvers02}
for a selection of the work done on using reflection in Coq.
Many other systems also support metareasoning and reflection:
Agda~\cite{Norell09,VanDerWalt12,VanDerWaltSwierstra12},
Idris~\cite{Christiansen:2014,Christiansen:2016,Christiansen:2016:Thesis}
Isabelle/HOL~\cite{ChaiebNipkow08},
Lean~\cite{ebner2017metaprogramming},
Maude~\cite{ClavelMeseguer02}, 
PVS~\cite{VonHenkeEtAl98}, 
reFLect~\cite{MelhamEtAl13},
and
Theorema~\cite{GieseBuchberger07,BuchbergerEtAl06}.

The semantics of the quotation operator $\synbrack{\cdot}$ is based on
the \emph{disquotational theory of quotation}~\cite{Quotation12}.
According to this theory, a quotation of an expression $e$ is an
expression that denotes $e$ itself.  In {\churchqe},
$\synbrack{\textbf{A}_\alpha}$ denotes a value that represents the
syntactic structure of $\textbf{A}_\alpha$.  Polonsky~\cite{Polonsky11} 
presents a set of axioms for quotation operators of this
kind.  Other theories of quotation have been proposed -- see
\cite{Quotation12} for an overview..  For instance, quotation can be viewed as
an operation that constructs literals for syntactic values~\cite{Rabe15}.

\section{Conclusion}\label{sec:conclusion}

\bibliography{imps,hol-light-qe}
\bibliographystyle{plain}

\setcounter{tocdepth}{1}
\listoftodos
\setcounter{tocdepth}{0}

\end{document}
