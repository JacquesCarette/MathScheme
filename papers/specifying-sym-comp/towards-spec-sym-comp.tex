\documentclass[fleqn]{llncs}
\usepackage{latexsym}
\usepackage{amssymb,amsmath}
\usepackage{stmaryrd}
\usepackage{graphicx}
%\usepackage{color}
\usepackage{hyperref}
\usepackage{phonetic}
\usepackage{xargs}
\usepackage[pdftex,dvipsnames]{xcolor}
\usepackage{listings}

\lstset{language=haskell,basicstyle=\ttfamily\small,breaklines=true,showspaces=false,
  showstringspaces=false,breakatwhitespace=true,texcl=true}

\input{towards-spec-sym-comp-def}

\usepackage[colorinlistoftodos,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}

\newcommand{\QQ}{\ensuremath{\mathbb{Q}}}
\newcommand{\NRE}{\ensuremath{\mname{normRatExpr}}}
\newcommand{\NRF}{\ensuremath{\mname{normRatFun}}}
\newcommand{\funQ}[1]{\ensuremath{\LambdaApp x : \QQ \mdot #1}}
\newcommand{\Lang}{\ensuremath{\mathcal{L}}}
\newcommand{\Langp}{\ensuremath{\mathcal{L}'}}

\title{Towards Specifying Symbolic Computation\thanks{This research is
    supported by NSERC.}}

\author{Jacques Carette and William M. Farmer}

\institute{%
Computing and Software, McMaster University, Canada\\
\url{http://www.cas.mcmaster.ca/~carette}\\
\url{http://imps.mcmaster.ca/wmfarmer}\\[1.5ex]
%21 Feburary 2019
}

\pagestyle{headings}

\iffalse

Examples:

  1. Factoring integers
  2. Change of representation for polynomials
  3. Normalization of rational expressions
  4. Integration by parts
  5. Symbolic differentiation
      o ln/exp example

Example format:

  1. Mathematical task
  2. How the task is performed in Maple
  3. Problems with performing the task
  4. Proposed solution
  5. Specification of the task in CTT_uqe

\fi

\begin{document}

\maketitle

\begin{abstract}

Many interesting and useful symbolic computation algorithms manipulate
mathematical expressions in mathematically meaningful ways.  Although
these algorithms are commonplace in computer algebra systems, they can
be surprisingly difficult to specify in a formal logic since they
involve an interplay of syntax and semantics.  In this paper we
discuss several examples of syntax-based mathematical algorithms, and
we show how to specify them in a formal logic with undefinedness,
quotation, and evaluation.

\end{abstract}

\iffalse 

\textbf{Keywords:} Symbolic computation, computer algebra systems,
reasoning about syntax, undefinedness, quotation and evaluation.

\fi

\section{Introduction}

\iffalse

A \emph{syntax-based mathematical algorithm (SBMA)} manipulates
mathematical expressions in a meaningful way.  SBMAs
are commonplace in mathematics.  Examples include algorithms that
compute arithmetic operations by manipulating numerals, linear
transformations by manipulating matrices, and derivatives by
manipulating functional expressions.  Reasoning about the mathematical
meaning of an SBMA requires reasoning about the relationship between
how the expressions are manipulated by the SBMA and what the
manipulations mean.

A \emph{syntax-based mathematical algorithm (SBMA)}~\cite{Farmer13},
such as a symbolic differentiation algorithm, manipulates mathematical
expressions in a mathematically meaningful way.

The \emph{computational
  behavior} of a transformer is the relationship between its input and
output expressions.  When the transformer is an SBMA, its
\emph{mathematical meaning} is the relationship between the
mathematical meanings of its input and output expressions.

\fi


\section{Background}

\subsection{Definedness, Equality, and Quasi-Equality}

Let $e$ be a mathematical expression and $D$ be a domain of
mathematical values.  We say \emph{$e$ is defined in $D$} if $e$
denotes an element in $D$.  When $e$ is defined in $D$, the
\emph{value of $e$ in $D$} is the element in $D$ that $e$ denotes.
When $e$ is undefined in $D$, the value of $e$ in $D$ is undefined.
Two expressions $e$ and $e'$ are \emph{equal in $D$}, written $e =_D
e'$, if they are both are defined in $D$ and they have the same values
in $D$ and are \emph{quasi-equal in $D$}, written $e \simeq_D e'$, if
either $e =_D e'$ or $e$ and $e'$ are both undefined in $D$.

\subsection{${\rm CTT}_{\rm uqe}$}

{\churchqe}~\cite{Farmer18} is a version of Church's type theory with
an inductive type of syntactic values that represent the expressions
of the logic, a quotation operator that maps expressions to syntactic
values, and an evaluation operator that maps syntactic values to the
values of the expressions that they represent.  These components
provide {\churchqe} with a \emph{global reflection facility} that is
well-suited for reasoning about the interplay of syntax and semantics
and, in particular, for specifying, defining, applying, and reasoning
about SBMAs.  The syntax and semantics of {\churchqe} is presented
in~\cite{Farmer18} in great detail.  A proof system for {\churchqe}
that is sound for all formulas and complete for formulas that do not
contain evaluations is also presented in~\cite{Farmer18}.  By
modifying HOL Light~\cite{Harrison09}, we have produced an
implementation of {\churchqe} called HOL Light
QE~\cite{CaretteFarmerLaskowski18}.

{\churchuqe}~\cite{Farmer17} is a variant of {\churchqe} that has
built-in support for partial functions and undefinedness based on the
traditional approach to undefinedness~\cite{Farmer04}.  It is
well-suited for specifying SBMAs that manipulate expressions that may
be undefined.  Its syntax and semantics are presented
in~\cite{Farmer17}.  A proof system for {\churchuqe} is not given
in~\cite{Farmer17}, but a proof system can be straightforwardly
derived by merging the proof systems for {\churchqe}~\cite{Farmer18}
and {\qzerou}~\cite{Farmer08a}.




\iffalse
syntax and semantics.  We have to be careful of \emph{which} semantics
is used to guide the syntactic manipulations, as different semantics
for the \textbf{same} expression can be inconsistent.

We are thus interested in the following questions:

\be

  \item What should the specification of the computational behavior of
    {\NRE} be?

  \item What is the mathematical meaning of {\NRE} be when {\NRE} is
    applied to the body of a rational function?

  \item What features of a logic are needed to express
    {\NRE}'s specification and mathematical meaning?

  \item What features of a logic would make expressing {\NRE}'s
    specification and mathematical meaning relatively straightforward?

\ee
\fi




\section{Rational Expressions, Rational Functions}

\subsection{Rational Expressions}

Let $e$ be an expression in the language $\Lang$ of the field
$\QQ(x)$, that is, a well-formed expression built from the symbols $x,
0, 1, +, *, -, \phantom{}^{-1}$, elements of $\QQ$ and parentheses (as
necessary).  For greater readability, we will take the liberty of
using fractional notation for $\phantom{}^{-1}$ and the exponential
notation $x^n$ for $x * \cdots * x$ ($n$ times).  $e$ can be something
simple like $\frac{x^4-1}{x^2-1}$ or something more complicated like
\begin{equation*}
\frac{\frac{1-x}{3/2 x^{18} + x + 17}}
     {\frac{1}{9834*x^{19393874}-1/5}}+3*x -\frac{12}{x}.
\end{equation*}
We assume that $\QQ \subseteq \QQ[x] \subseteq \QQ(x)$ so that the
field of rational numbers and the ring of polynomials in $x$ are
included in $\QQ(x)$.  The expressions in $\Lang$ are intended to
denote elements in $\QQ(x)$.  Of course, expressions like $x/0$ are
undefined in $\QQ(x)$.  We will call members of $\Lang$ \emph{rational
  expressions (over $\QQ$)}.

We are taught that, like for members of $\QQ$ (such as $5/15$), there
is a \emph{normal form} for rational expressions. This is typically
defined to be a rational expression $p/q$ for two polynomials $p,q \in \QQ[x]$
such that $p$ and $q$ are themselves in polynomial normal form and
$\mname{gcd}(p,q) = 1$.  The motivation for the latter
property is that we usually want to write $\frac{x^4-1}{x^2-1}$ as
$x^2 + 1$ just as we usually want to write $5/15$ as $1/3$.  Thus, the
normal forms of $\frac{x^4-1}{x^2-1}$ and $\frac{x}{x}$ are $x^2 + 1$
and $1$, respectively.  This definition of normal form is based on the
characteristic that the elements of the \emph{field of fractions} of a
ring $R$ can be written as quotients $r/s$ of elements of $R$ where
$r_0/s_0 = r_1/s_1$ if and only if $r_0 * s_1 = r_1 * s_0$ in $R$.

Every computer algebra system implements a function that
\emph{normalizes} expressions that denote elements of $\QQ(x)$
(including elements of $\QQ$ and $\QQ[x]$).  \change{Unfortunately
that statement is not quite right, because normalization in a CAS merely means
that the result can checked to be 0 (or not) in O(1) time. This leads
to different normalizations for all 3, implemented in 3 different
functions. It turns out that, in the univariate case, they correspond,
but already for 2 variables things are different.}
\info{I think you might be conflating what CAS people call normal and
canonical. Normal just means O(1) zero-testing, while canonical means
a = b iff C(a) = C(b) with the later = being O(1) because of 
hash-consing}
Let {\NRE} be the name of
the algorithm that implements this normalization function on $\Lang$.
Thus the signature of $\NRE$ is $\Lang \rightarrow \Lang$ and the
specification of $\NRE$ is that, for all $e \in \Lang$, (A) $\NRE(e)$
is a normal form and (B) $e \simeq_{\QQ(x)} \NRE(e)$.  $\NRE$ is an
example of an SBMA.  (A) is the syntactic component of its
specification, and (B) is the semantic component.
\change{in the above, you never actually define what a normal form is!}

\subsection{Rational Functions}

Let $\Langp$ be the set of expressions of the form $\LambdaApp x : \QQ
\mdot e$ where $e \in \Lang$.  We will call members of $\Langp$
\emph{rational functions (over $\QQ$)}.  That is, a rational function
is a lambda expression whose body is a rational expression.  

If $f_i = \funQ{e_i}$ are rational functions for $i=1,2$, one might
think that $f_1 =_{\QQ \rightarrow \QQ} f_2$ if $e_1 =_{\QQ(x)} e_2$.
But this is not the case.  For example, the rational functions
$\funQ{x/x}$ and $\funQ{1}$ are not equal since $\funQ{x/x}$ is
undefined at 0 while $\funQ{1}$ is defined everywhere.  But $x/x
=_{\QQ(x)} 1$! Similarly, $\funQ{(1/x - 1/x)} \not=_{\QQ \rightarrow
  \QQ} \funQ{0}$ and $(1/x - 1/x) =_{\QQ(x)} 0$.  Note that, in some
contexts, we might want to say that $\funQ{x/x}$ and $\funQ{1}$ do
indeed denote the same function by invoking the concept of
\emph{removable singularities}.
%
\unsure{I don't see why this reasoning is less clear as a
  justification that $\funQ{(1/x - 1/x)}$ and $\funQ{0}$ are equal.}

As we have just seen, we cannot normalize a rational function by
normalizing its body, but we can normalize rational functions if we
are careful not to remove points of undefinedness.  Let a
\emph{quasinormal form} be a rational expression $p/q$ for two
polynomials $p,q \in \QQ[x]$ such that $p$ and $q$ are themselves in
polynomial normal form and there is no irreducible polynomial $r \in
\QQ[x]$ of degree $\ge 2$ that divides both $p$ and $q$.  We can then
normalize a rational function by quasinormalizing its body.  Let
{\NRF} be the name of the algorithm that implements this normalization
function on $\Langp$.  Thus the signature of $\NRF$ is $\Langp
\rightarrow \Langp$ and the specification of $\NRF$ is that, for all
$\funQ{e} \in \Langp$, (A) $\NRF(\funQ{e}) = \funQ{e'}$ where $e'$ is
a quasinormal form and (B) $\funQ{e} \simeq_{\QQ \rightarrow \QQ}
\NRF(\funQ{e})$.  $\NRF$ is another example of an SBMA.  (A) is the
syntactic component of its specification, and (B) is the semantic
component.
\unsure{Why those conditions on $r$? It is ok, over $\QQ(x)$, to remove
a common factor of $x^2+1$. Or even $x^2-2$ !}

\subsection{The Problem Here}

So why are we concerned about rational expressions and rational
functions?  The reason is that computer algebra systems make little
distinction between the two: a rational expression can be interpreted
sometimes as a rational expression and sometimes as a rational
function.  For example, one can always \emph{evaluate} an expression
by assigning values to its free variables or even convert it to a
function.  In Maple\footnote{Mathematica has similar commands.}, these
are done respectively via \texttt{eval(e, x = 0)} and
\texttt{unapply(e, x)}.  We can exhibit the problematic behaviour as
follows: \todo{insert some Maple code with output here} In fact, there
is an even more pervasive, one could even say \emph{obnoxious}, way of
doing this: as the underlying language is \emph{imperative}, it is
possible to do:
\begin{verbatim}
  e := (x^4-1)/(x^2-1);
  # many, many more lines of 'code'
  x := 1;
   try to use 'e'
\end{verbatim}

Hence, if an expression $e$ is interpreted as a function, then it is
not valid to simplify the function by applying {\NRE} to $e$, but
computer algebra systems let the user do exactly this because usually
there is no distinction made between $e$ as a rational expression and
$e$ as representing a rational function, as we have already mentioned.

To avoid unsound applications of {\NRE}, {\NRF}, and other SBMAs in
mathematical systems, we need to carefully, if not formally, specify
what these algorithms are intended to do.  This is not a
straightforward task to do in a traditional logic since SBMAs involve
an interplay of syntax and semantics and algorithms like {\NRE} and
{\NRF} are very sensitive to definedness considerations.  In the next
subsection we will show how these two algorithms can be specified in a
version of formal logic with undefinedness, quotation, and evaluation.

\unsure{I don't know why we need to say this: ``Of course, given some
  symbol $y$, $f(y)$ \textbf{is} in $\Lang$.''}

\subsection{The Formal Specification of {\NRE} and {\NRF}}

We will specify {\NRE} and {\NRF} in {\churchuqe}.  To do this we need
to develop a theory $T = (L,\Gamma)$ of {\churchuqe} in which {\NRE}
and {\NRF} are constants in $L$, the language $L$ of $T$, and their
specifications are formulas in $\Gamma$, the set of axioms of $T$.  A
complete development of $T$ would be long and tedious, so we will only
sketch the development of $T$.

The first step is to define a theory $T_0 = (L_0,\Gamma_0)$ that
axiomatizes $\QQ$, the field of rational numbers.  $L_0$ contains a
base type $q$ and constants $0_q$, $1_q$, $+_{q \tarrow q \tarrow q}$,
$*_{q \tarrow q \tarrow q}$, $-_{q \tarrow q}$, and
$\phantom{}^{{-1}_{q \tarrow q}}$ representing the standard elements
and operators of a field.  $\Gamma_0$ contains axioms that say the
type $q$ is the field of rational numbers.

The second step is to extend $T_0$ to a theory $T_1 = (L_1,\Gamma_1)$
that axiomatizes $\QQ(x)$, the field of rational expressions over
$\QQ$.  $L_0$ contains a base type $r$; constants $0_r$, $1_r$, $+_{r
  \tarrow r \tarrow r}$, $*_{r \tarrow r \tarrow r}$, $-_{r \tarrow
  r}$, and $\phantom{}^{{-1}_{r \tarrow r}}$ representing the standard
elements and operators of a field; and a constant $X_r$ representing
the indeterminant of $\QQ(x)$.  $\Gamma_0$ contains axioms that say
the type $r$ is the field of rational expressions over $\QQ$.  Notice
that the types $q$ and $r$ are completely separate from each other
since {\churchuqe} does not admit subtypes as in~\cite{Farmer93b}.

The third step is to extend $T_1$ to a theory $T_2 = (L_2,\Gamma_2)$
that is equipped to express ideas about the expressions of type $q$
and $q \tarrow q$ that have the form of rational expressions and
rational functions, respectively.  $T_2$ is obtain by defining 
the following constants:

\be

  \item $\mname{RatExpr}_{\epsilon \tarrow o}$ is the predicate
    representing the subtype of $\epsilon$ that denotes the
    expressions of type $q$ that have the form of rational expressions
    in $x_q$ (i.e., the expressions of type $q$ built from the
    variable $x_q$ and the constants representing the field elements
    and operators for $q$).  Thus $\mname{RatExpr}_{\epsilon \tarrow
      o} \, \synbrack{x_q/x_q}$ is valid in $T_2$.

  \item $\mname{RatFun}_{\epsilon \tarrow o}$ is the predicate
    representing the subtype of $\epsilon$ that denotes the
    expressions of type $q \tarrow q$ that are rational functions in
    $x_q$ (i.e., the expressions of the form $\LambdaApp x_q \mdot
    \textbf{R}_q$ where $\textbf{R}_q$ is an expression having the
    form of a rational expression in $x_q$).  Thus
    $\mname{RatFun}_{\epsilon \tarrow o} \, \synbrack{\LambdaApp x_q
      \mdot x_q/x_q}$ is valid in $T_2$.

  \item \bsp $\mname{val-in-}r_{\epsilon \tarrow r}$ is a partial
    function that maps each member of the subtype
    $\mname{RatExpr}_{\epsilon \tarrow o}$ to its denotation in $r$.
    Thus $\mname{val-in-}r_{\epsilon \tarrow r} \, \synbrack{x_q +_{q
        \tarrow q \tarrow q} 1_q} = X_r +_{r \tarrow r \tarrow r} 1_r$
    and $(\mname{val-in-}r_{\epsilon \tarrow r} \,
    \synbrack{1_q/0_q})\IsUndefApp$ are valid in $T_2$.  Notice that
    the function is partial since an expression like $1_q/0_q$ does
    not denote a member of either the field $q$ or $r$. \esp

  \item \bsp $\mname{Norm}_{\epsilon \tarrow o}$ is the predicate
    representing the subtype of $\epsilon$ that denotes the members of
    the subtype $\mname{RatExpr}_{\epsilon \tarrow o}$ that are normal
    forms.  Thus $\Neg(\mname{Norm}_{\epsilon \tarrow o}
    \, \synbrack{x_q/x_q})$ and $\mname{Norm}_{\epsilon
      \tarrow o} \, \synbrack{1_q}$ are valid in $T_2$.\esp

  \item \bsp $\mname{Quasinorm}_{\epsilon \tarrow o}$ is the predicate
    representing the subtype of $\epsilon$ that denotes the members of
    the subtype $\mname{RatExpr}_{\epsilon \tarrow o}$ that are
    quasinormal forms.  Thus $\mname{Quasinorm}_{\epsilon \tarrow o}
    \, \synbrack{x_q/x_q}$ and $\Neg(\mname{Quasinorm}_{\epsilon
      \tarrow o} \, \synbrack{A_q/A_q})$, where $A_q$ is $x^{2}_{q}
    +_{q \tarrow q \tarrow q} 1_q$, are valid in $T_2$. \esp

  \item $\mname{body}_{\epsilon \tarrow \epsilon}$ is a partial
    function that maps each member of $\epsilon$ denoting an
    expression of the form $\LambdaApp x_\alpha \mdot B_\beta$ to the
    member of $\epsilon$ that denotes $B_\beta$ and is undefined on
    the rest of $\epsilon$.

\ee

\bsp The final step is to extend $T_2$ to a theory $T = (L,\Gamma)$ in
which $L$ has two additional constants $\mname{normRatExpr}_{\epsilon
  \tarrow \epsilon}$ and $\mname{normRatFun}_{\epsilon \tarrow
  \epsilon}$ and $\Gamma$ has two additional axioms
$\mname{specNormRatExpr}_o$ and $\mname{specNormRatFun}_o$ that
specify $\mname{normRatExpr}_{\epsilon \tarrow \epsilon}$ and
$\mname{normRatFun}_{\epsilon \tarrow
  \epsilon}$. $\mname{specNormRatExpr}_o$ is the formula\esp
\begin{align}
&
\ForallApp u_\epsilon \mdot\\
& \hspace*{2ex}
\If \; (\mname{RatExpr}_{\epsilon \tarrow o} \, u_\epsilon)\\
& \hspace*{4ex}
(\mname{Norm}_{\epsilon \tarrow \epsilon}(\mname{normRatExpr}_{\epsilon \tarrow o} \, u_\epsilon) \And {}\\
& \hspace*{6ex}
\mname{val-in-}r_{\epsilon \tarrow r} \, u_\epsilon \QuasiEqual
\mname{val-in-}r_{\epsilon \tarrow r}(\mname{normRatExpr}_{\epsilon \tarrow o} \, u_\epsilon))\\
& \hspace*{4ex}
(\mname{normRatExpr}_{\epsilon \tarrow o} \, u_\epsilon)\IsUndefApp
\end{align}
(3) says that, if the input represents a rational expression in $x_q$,
then the output represents a rational expression in $x_q$ in normal
form.  (4) says that, if the input represents a rational expression in
$x_q$, then either the input and output denote the same member of $r$
or they both do not denote any member of $r$.  And (5) says that, if
the input does not represent a rational expression in $x_q$, then the
output is undefined.

$\mname{specNormRatFun}_o$ is the formula
\begin{align}
&
\ForallApp u_\epsilon \mdot\\
& \hspace*{2ex}
\If \; (\mname{RatFun}_{\epsilon \tarrow o} \, u_\epsilon)\\
& \hspace*{4ex}
(\mname{RatFun}_{\epsilon \tarrow o} \, (\mname{normRatFun}_{\epsilon \tarrow o} \, u_\epsilon) \And {}\\
& \hspace*{6ex}
\mname{Quasinorm}_{\epsilon \tarrow \epsilon}(\mname{body}_{\epsilon \tarrow \epsilon}(\mname{normRatExpr}_{\epsilon \tarrow o} \, u_\epsilon)) \And {}\\
& \hspace*{6ex}
\sembrack{u_\epsilon}_{r \tarrow r} =
\sembrack{\mname{normRatExpr}_{\epsilon \tarrow o} \, u_\epsilon}_{r \tarrow r})\\
& \hspace*{4ex}
(\mname{normRatFun}_{\epsilon \tarrow o} \, u_\epsilon)\IsUndefApp
\end{align}
(8-9) say that, if the input represents a rational function in $x_q$,
then the output represents a rational function in $x_q$ whose body is
in quasinormal form.  (10) says that, if the input represents a
rational function in $x_q$, then input and output denote the same
(possibly partial) function on the rational numbers.  And (11) says
that, if in input does not represent a rational function in $x_q$,
then the output is undefined.

Not only is it possible to specifying the algorithms
$\mname{normRatExpr}$ and $\mname{normRatFun}$ in {\churchuqe}, it is
also possible to define the functions that these algorithms implement.
Then applications of these functions can be evaluated using a proof
system for {\churchuqe}.

\section{Symbolic Differentiation of Rational Functions}


\section{Related Work}

\section{Conclusion}

\bibliography{imps}
\bibliographystyle{splncs04}

\setcounter{tocdepth}{1}
\listoftodos
\setcounter{tocdepth}{0}

\end{document}
