\documentclass[fleqn]{llncs}
\usepackage{latexsym}
\usepackage{amssymb,amsmath}
\usepackage{stmaryrd}
\usepackage{graphicx}
%\usepackage{color}
\usepackage{hyperref}
\usepackage{phonetic}
\usepackage{xargs}
\usepackage[pdftex,dvipsnames]{xcolor}
\usepackage{listings}

\lstset{language=haskell,basicstyle=\ttfamily\small,breaklines=true,showspaces=false,
  showstringspaces=false,breakatwhitespace=true,texcl=true}

\input{towards-spec-sym-comp-def}

\usepackage[colorinlistoftodos,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}

\newcommand{\QQ}{\ensuremath{\mathbb{Q}}}
\newcommand{\NRE}{\ensuremath{\mname{normRatExpr}}}
\newcommand{\NRF}{\ensuremath{\mname{normRatFun}}}
\newcommand{\funQ}[1]{\ensuremath{\LambdaApp x : \QQ \mdot #1}}
\newcommand{\Lang}{\ensuremath{\mathcal{L}}}
\newcommand{\Langp}{\ensuremath{\mathcal{L}'}}

\title{Towards Specifying Symbolic Computation\thanks{This research is
    supported by NSERC.}}

\author{Jacques Carette and William M. Farmer}

\institute{%
Computing and Software, McMaster University, Canada\\
\url{http://www.cas.mcmaster.ca/~carette}\\
\url{http://imps.mcmaster.ca/wmfarmer}\\[1.5ex]
%21 Feburary 2019
}

\pagestyle{headings}

\iffalse

Examples:

  1. Factoring integers
  2. Change of representation for polynomials
  3. Normalization of rational expressions
  4. Integration by parts
  5. Symbolic differentiation
      o ln/exp example

Example format:

  1. Mathematical task
  2. How the task is performed in Maple
  3. Problems with performing the task
  4. Proposed solution
  5. Specification of the task in CTT_uqe

\fi

\begin{document}

\maketitle

\begin{abstract}

Many interesting and useful symbolic computation algorithms manipulate
mathematical expressions in mathematically meaningful ways.  Although
these algorithms are commonplace in computer algebra systems, they can
be surprisingly difficult to specify in a formal logic since they
involve an interplay of syntax and semantics.  In this paper we
discuss several examples of syntax-based mathematical algorithms, and
we show how to specify them in a formal logic with undefinedness,
quotation, and evaluation.

\end{abstract}

\iffalse 

\textbf{Keywords:} Symbolic computation, computer algebra systems,
reasoning about syntax, undefinedness, quotation and evaluation.

\fi

\section{Introduction}

\section{Background}

Let $e$ be a mathematical expression and $D$ be a domain of
mathematical values.  We say \emph{$e$ is defined in $D$} if $e$
denotes an element in $D$.  When $e$ is defined in $D$, the
\emph{value of $e$ in $D$}, written $\mname{val}_D(e)$, is the element
in $D$ that $e$ denotes.  When $e$ is undefined in $D$, the value of
$e$ in $D$ and $\mname{val}_D(e)$ are undefined.  Two expressions $e$
and $e'$ are \emph{equal in $D$}, written $e =_D e'$, if $e$ and $e'$
are defined in $D$ and $\mname{val}_D(e) = \mname{val}_D(e')$ and are
\emph{quasi-equal in $D$}, written $e \simeq_D e'$, if either $e =_D
e'$ or $e$ and $e'$ are both undefined in $D$.

\iffalse
SBMAs can be difficult to specify since they involve an interplay of
syntax and semantics.  We have to be careful of \emph{which} semantics
is used to guide the syntactic manipulations, as different semantics
for the \textbf{same} expression can be inconsistent.

We are thus interested in the following questions:

\be

  \item What should the specification of the computational behavior of
    {\NRE} be?

  \item What is the mathematical meaning of {\NRE} be when {\NRE} is
    applied to the body of a rational function?

  \item What features of a logic are needed to express
    {\NRE}'s specification and mathematical meaning?

  \item What features of a logic would make expressing {\NRE}'s
    specification and mathematical meaning relatively straightforward?

\ee
\fi




\section{Rational Expressions, Rational Functions}

\subsection{Rational Expressions}

Let $e$ be an expression in the language $\Lang$ of the field
$\QQ(x)$, that is, a well-formed expression built from the symbols $x,
0, 1, +, *, -, \phantom{}^{-1}$, elements of $\QQ$ and parentheses (as
necessary).  For greater readability, we will take the liberty of
using fractional notation for $\phantom{}^{-1}$ and the exponential
notation $x^n$ for $x * \cdots * x$ ($n$ times).  $e$ can be something
simple like $\frac{x^4-1}{x^2-1}$ or something more complicated like
\begin{equation*}
\frac{\frac{1-x}{3/2 x^{18} + x + 17}}
     {\frac{1}{9834*x^{19393874}-1/5}}+3*x -\frac{12}{x}.
\end{equation*}
We assume that $\QQ \subseteq \QQ[x] \subseteq \QQ(x)$ so that the
field of rational numbers and the ring of polynomials in $x$ are
included in $\QQ(x)$.  The expressions in $\Lang$ are intended to
denote elements in $\QQ(x)$.  Of course, expressions like $x/0$ are
undefined in $\QQ(x)$.  We will call members of $\Lang$ \emph{rational
  expressions (over $\QQ$)}.

We are taught that, like for members of $\QQ$ (such as $5/15$), there
is a \emph{normal form} for rational expressions. This is typically
defined to be a rational expression $p/q$ for two polynomials $p,q \in \QQ[x]$
such that $p$ and $q$ are themselves in polynomial normal form and
$\mname{gcd}(p,q) = 1$.  The motivation for the latter
property is that we usually want to write $\frac{x^4-1}{x^2-1}$ as
$x^2 + 1$ just as we usually want to write $5/15$ as $1/3$.  Thus, the
normal forms of $\frac{x^4-1}{x^2-1}$ and $\frac{x}{x}$ are $x^2 + 1$
and $1$, respectively.  This definition of normal form is based on the
characteristic that the elements of the \emph{field of fractions} of a
ring $R$ can be written as quotients $r/s$ of elements of $R$ where
$r_0/s_0 = r_1/s_1$ if and only if $r_0 * s_1 = r_1 * s_0$ in $R$.

Every computer algebra system implements a function that
\emph{normalizes} expressions that denote elements of $\QQ(x)$
(including elements of $\QQ$ and $\QQ[x]$).  \change{Unfortunately
that statement is not quite right, because normalization in a CAS merely means
that the result can checked to be 0 (or not) in O(1) time. This leads
to different normalizations for all 3, implemented in 3 different
functions. It turns out that, in the univariate case, they correspond,
but already for 2 variables things are different.}
\info{I think you might be conflating what CAS people call normal and
canonical. Normal just means O(1) zero-testing, while canonical means
a = b iff C(a) = C(b) with the later = being O(1) because of 
hash-consing}
Let {\NRE} be the name of
the algorithm that implements this normalization function on $\Lang$.
Thus the signature of $\NRE$ is $\Lang \rightarrow \Lang$ and the
specification of $\NRE$ is that, for all $e \in \Lang$, (A) $\NRE(e)$
is a normal form and (B) $e \simeq_{\QQ(x)} \NRE(e)$.  $\NRE$ is an
example of an SBMA.  (A) is the syntactic component of its
specification, and (B) is the semantic component.
\change{in the above, you never actually define what a normal form is!}

\subsection{Rational Functions}

Let $\Langp$ be the set of expressions of the form $\LambdaApp x : \QQ
\mdot e$ where $e \in \Lang$.  We will call members of $\Langp$
\emph{rational functions (over $\QQ$)}.  That is, a rational function
is a lambda expression whose body is a rational expression.  

If $f_i = \funQ{e_i}$ are rational functions for $i=1,2$, one might
think that $f_1 =_{\QQ \rightarrow \QQ} f_2$ if $e_1 =_{\QQ(x)} e_2$.
But this is not the case.  For example, the rational functions
$\funQ{x/x}$ and $\funQ{1}$ are not equal since $\funQ{x/x}$ is
undefined at 0 while $\funQ{1}$ is defined everywhere.  But $x/x
=_{\QQ(x)} 1$! Similarly, $\funQ{(1/x - 1/x)} \not=_{\QQ \rightarrow
  \QQ} \funQ{0}$ and $(1/x - 1/x) =_{\QQ(x)} 0$.  Note that, in some
contexts, we might want to say that $\funQ{x/x}$ and $\funQ{1}$ do
indeed denote the same function by invoking the concept of
\emph{removable singularities}.
%
\unsure{I don't see why this reasoning is less clear as a
  justification that $\funQ{(1/x - 1/x)}$ and $\funQ{0}$ are equal.}

As we have just seen, we cannot normalize a rational function by
normalizing its body, but we can normalize rational functions if we
are careful not to remove points of undefinedness.  Let a
\emph{quasinormal form} be a rational expression $p/q$ for two
polynomials $p,q \in \QQ[x]$ such that $p$ and $q$ are themselves in
polynomial normal form and there is no irreducible polynomial $r \in
\QQ[x]$ of degree $\ge 2$ that divides both $p$ and $q$.  We can then
normalize a rational function by quasinormalizing its body.  Let
{\NRF} be the name of the algorithm that implements this normalization
function on $\Langp$.  Thus the signature of $\NRF$ is $\Langp
\rightarrow \Langp$ and the specification of $\NRF$ is that, for all
$\funQ{e} \in \Langp$, (A) $\NRF(\funQ{e}) = \funQ{e'}$ where $e'$ is
a quasinormal form and (B) $\funQ{e} \simeq_{\QQ \rightarrow \QQ}
\NRF(\funQ{e})$.  $\NRF$ is another example of an SBMA.  (A) is the
syntactic component of its specification, and (B) is the semantic
component.
\unsure{Why those conditions on $r$? It is ok, over $\QQ(x)$, to remove
a common factor of $x^2+1$. Or even $x^2-2$ !}

\subsection{The Problem Here}

So why are we concerned about rational expressions and rational
functions?  The reason is that computer algebra systems make little
distinction between the two: a rational expression can be interpreted
sometimes as a rational expression and sometimes as a rational
function.  For example, one can always \emph{evaluate} an expression
by assigning values to its free variables or even convert it to a
function.  In Maple\footnote{Mathematica has similar commands.}, these
are done respectively via \texttt{eval(e, x = 0)} and
\texttt{unapply(e, x)}.  We can exhibit the problematic behaviour as
follows: \todo{insert some Maple code with output here} In fact, there
is an even more pervasive, one could even say \emph{obnoxious}, way of
doing this: as the underlying language is \emph{imperative}, it is
possible to do:
\begin{verbatim}
  e := (x^4-1)/(x^2-1);
  # many, many more lines of 'code'
  x := 1;
   try to use 'e'
\end{verbatim}

Hence, if an expression $e$ is interpreted as a function, then it is
not valid to simplify the function by applying {\NRE} to $e$, but
computer algebra systems let the user do exactly this because usually
there is no distinction made between $e$ as a rational expression and
$e$ as representing a rational function, as we have already mentioned.

To avoid unsound applications of {\NRE}, {\NRF}, and other SBMAs in
mathematical systems, we need to carefully, if not formally, specify
what these algorithms are intended to do.  This is not a
straightforward task to do in a traditional logic since SBMAs involve
an interplay of syntax and semantics and algorithms like {\NRE} and
{\NRF} are very sensitive to definedness considerations.  In the next
subsection we will show how these two algorithms can be specified in a
version of formal logic with undefinedness, quotation, and evaluation.

\unsure{I don't know why we need to say this: ``Of course, given some
  symbol $y$, $f(y)$ \textbf{is} in $\Lang$.''}

\subsection{The Formal Specification of {\NRE} and {\NRF}}

\section{Related Work}

\section{Conclusion}

\bibliography{imps}
\bibliographystyle{splncs04}

\setcounter{tocdepth}{1}
\listoftodos
\setcounter{tocdepth}{0}

\end{document}
