\documentclass[t,12pt,numbers,fleqn]{beamer}
%\documentclass[t,12pt,numbers,fleqn,handout]{beamer}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}

\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{wasysym}
\usepackage{color}
\usepackage{url}
\usepackage{phonetic}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{arrows,decorations,decorations.pathmorphing}
\usepackage{array}
\usepackage{pgf}
%\usepackage{pgfpages} 
\usepackage{multirow} 

%\iffalse
% for Agda
\usepackage[references]{agda}
\DeclareUnicodeCharacter{8799}{$\stackrel{?}{=}$}
\DeclareUnicodeCharacter{931}{$\Sigma$}
\DeclareUnicodeCharacter{9679}{\ensuremath{\bullet}}
\DeclareUnicodeCharacter{945}{\ensuremath{\alpha}}
\DeclareUnicodeCharacter{964}{\ensuremath{\tau}}
\DeclareUnicodeCharacter{958}{\ensuremath{\xi}}
\DeclareUnicodeCharacter{8759}{\ensuremath{\:\!\!\:}}
%\fi

%\pgfpagesuselayout{resize to}[letterpaper, border shrink=5mm,landscape] 
%\pgfpagesuselayout{2 on 1}[letterpaper,border shrink=5mm] 

\usepackage{fancybox}
%\usepackage{times}

\useoutertheme{split}

\mode<presentation>{}

%\mode<presentation>{
%\usecolortheme{whale}
%\usecolortheme{orchid}
%\useinnertheme[shadow]{rounded}
%}

%\setbeamerfont{structure}{series=\bfseries}
%\usefonttheme[stillsansseriftext,stillsansserifmath]{serif}
%\usetheme{Madrid}

\setbeamertemplate{navigation symbols}{} 
\setbeamertemplate{itemize item}[ball]
\setbeamersize{text margin left = 4mm}
\setbeamersize{text margin right = 4mm}

\input{def-beamer}

\newcommand{\qzero}{${\cal Q}_0$}
\newcommand{\qzerou}{${\cal Q}^{\rm u}_{0}$}
\newcommand{\qzerouqe}{${\cal Q}^{\rm uqe}_{0}$}
\newcommand{\churchqe}{$\mbox{\sc ctt}_{\rm qe}$}
\newcommand{\churchuqe}{$\mbox{\sc ctt}_{\rm uqe}$}
\newcommand{\syn}[1]{\textcolor{red}{#1}}

\newtheorem{biformthy}{Biform Theory}
\newtheorem{thymorphism}{Theory Morphism}

\newcommand{\inclusion}{\hookrightarrow}
\newcommand{\view}{\leadsto}
\tikzstyle{thy}=[draw, circle, thick]
\tikzstyle{inclusion-arrow}= [right hook-angle 45, thick]
\tikzstyle{preview}=[decorate,
                     decoration={coil,aspect=0,amplitude=1pt,
                                 segment length=6pt,
                                 pre=lineto,pre length=5pt,
                                 post=lineto,post length=7pt},
                     thick]
\tikzstyle{view-arrow}= [preview,-angle 45, thick]

\begin{document}

\title{ {\normalsize \bgreen{\bf CICM 2017}}\\[1.5ex] {\large \bf
    Formalizing Mathematical Knowledge as a Biform Theory Graph: A
    Case Study}
}

\author[Farmer]{
Jacques Carette and \underline{William M. Farmer}
}

\institute{
Department of Computing and Software\\
McMaster University
} 

\date{ {\small 18 July 2017} }
% Jacques: comment this out as the file should be in the repo too.  
%\bc
% \includegraphics[scale = 0.2, keepaspectratio]{$HOME/doc/images/mcmaster-logo-full-color.jpg}
%\ec
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\setbeamertemplate{footline}{}
\begin{frame}
\vspace{-1.5ex} 
\titlepage
\end{frame}

\setbeamertemplate{footline}{
\begin{beamercolorbox}{sectioninhead/foot}
\bblue{\hrulefill}

\vspace{1ex}
\hspace{1ex}
{\tiny W. M. Farmer
\hfill 
Formalizing Mathematical Knowledge as a Biform Theory Graph: A Case Study
\hfill
\insertframenumber/\ref{lastframe}}
\vspace{1ex}
\end{beamercolorbox}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{MathScheme Project {\small \bbrown{[CFO11]}}}
\bi

  \item A long-term project at McMaster University lead by Jacques
    Carette and William Farmer.

  \item Its objective is to develop a new approach to mechanized
    mathematics in which \bgreen{axiomatic and algorithmic mathematics are
    tightly integrated.}

  \item \bbrown{Two key ideas}: 

  \be

    \item \bblue{Little theories method}.

    \item \bblue{Biform theories}.

  \ee

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Little Theories Method {\small \bbrown{[FGT92]}}}
\bi

  \item A complex body of mathematical knowledge is encoded by the
    \bblue{little theories method} as a \bblue{theory graph}
    \bbrown{[Kol14]} in which:

  \be

    \item The nodes are \bblue{theories}.

    \item The edges are \bblue{theory morphisms}, meaning-preserving
      mappings from one theory to another.

  \ee

  \item The theory morphisms are \bgreen{information conduits} that
    enable definitions and theorems to be transported between
    theories.

  \item A theory graph enables formalization at the most convenient
    level of abstraction using the most convenient vocabulary.

  \item The \bblue{tiny theories method} is a refinement in which each
    theory is obtained from another theory by the addition of a single
    concept.

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Biform Theories {\small \bbrown{[FM03,CF08]}}}
\bi

  \item A \bblue{biform theory} is a triple $T =
    (L,\Pi,\Gamma)$ where:

  \be

    \item $L$ is a language of some underlying logic that is generated from a
      set of \bblue{symbols} (e.g., types and constants).

    \item The expressions in $L$ denote mathematical values that
      include \bblue{syntactic values} representing the expressions of
      $L$.

    \item $\Pi$ is a set of \bblue{transformers} that implement
      functions on the expressions of $L$ and are represented by
      symbols of $L$.

    \item $\Gamma$ is a set of \bblue{axioms} (formulas of $L$) that
      express properties about the symbols (and thus about the
      transformers) of $L$.

  \ee

  \item Transformers may be specified in $T$ but implemented externally.

  \item $T$ is an \bblue{axiomatic theory} if $\Pi$ is empty and an
    \bblue{algorithmic theory} if $\Gamma$ is empty.

  \item An implementation of a biform theory requires a
    \bgreen{metareasoning infrastructure with reflection} using a
    \bgreen{local} or \bgreen{global} approach.

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Metareasoning Infrastructure}
\begin{figure}
\center
\begin{tikzpicture}[scale=.6]
  \filldraw[very thick, fill=gray!20] (0,0) circle (3);
    \draw (-1.8,+1.8) node {\Large $L$};
  \filldraw[very thick, fill=yellow!40] (+1,0) circle (1);
    \draw (+1,0) node {\Large $L_{\rm obj}$};
  \filldraw[very thick, fill=brown!40] (+6,0) circle (1);
    \draw (+6,0) node {\Large $L_{\rm syn}$};
  \draw[-triangle 45, very thick, color=blue!80!black] (+1,+1) -- (+6,+1);
    \draw[right] (+2.8,+1.7) node {\Large \bblue{quotation}};
  \draw[-triangle 45, very thick, color=red!80!black] (+6,-1) -- (+1,-1);
    \draw[right] (+2.8,-1.7) node {\Large \bred{evaluation}};
  \draw[-triangle 45, color=green!55!black] (7,0) .. controls 
    (8.5,.5) and (8.13,-2.13) .. (6.71,-.71);
    \draw[right] (7.9,-.4) node {\bgreen{alg}};
\end{tikzpicture}
\end{figure}

\medskip

\bi

  \item[] $L$: language of the logic.

  \item[] $L_{\rm obj}$: language on which to perform computation.

  \item[] $L_{\rm syn}$: language of syntactic values for $L_{\rm
    obj}$ (in the metalogic).

\ei

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Metareasoning with Local Reflection}
\begin{figure}
\center
\begin{tikzpicture}[scale=.6]
  \filldraw[very thick, fill=gray!20] (3.5,0) ellipse (6 and 4);
    \draw (0,+2.6) node {\Large $L$};
  \filldraw[very thick, fill=yellow!40] (+1,0) circle (1);
    \draw (+1,0) node {\Large $L_{\rm obj}$};
  \filldraw[very thick, fill=brown!40] (+6,0) circle (1);
    \draw (+6,0) node {\Large $L_{\rm syn}$};
  \draw[-triangle 45, very thick, color=blue!80!black] (+1,+1) -- (+6,+1);
    \draw[right] (+1.8,+1.7) node {\Large \bblue{quotation}};
  \draw[-triangle 45, very thick, color=red!80!black] (+6,-1) -- (+1,-1);
    \draw[right] (+1.8,-1.7) node {\Large \bred{evaluation}};
  \draw[-triangle 45, color=green!55!black] (7,0) .. controls 
    (8.5,.5) and (8.13,-2.13) .. (6.71,-.71);
    \draw[right] (7.9,-.4) node {\bgreen{alg}};
\end{tikzpicture}
\end{figure}

\medskip

\bi

  \item[] \bblue{Advantages}: (1) $L_{\rm syn}$ resides in the logic and\\
    (2) the approach is implementable in many logics.

  \item[] \bblue{Disadvantage}: Does not scale up --- many of these
    infrastructures are needed.

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Metareasoning with Global Reflection}
\vspace*{-3ex}
\begin{figure}
\center
\begin{tikzpicture}[scale=.6]
  \filldraw[very thick, fill=yellow!40] (3.5,0) ellipse (6 and 4);
    \draw (+1.4,+2.6) node {\Large $L=L_{\rm obj}$};
  \filldraw[very thick, fill=brown!40] (+6,0) circle (1);
    \draw (+6,0) node {\Large $L_{\rm syn}$};
  \draw[-triangle 45, very thick, color=blue!80!black] (3.5,4) .. controls
    (5.5,5.5) and (6,2).. (6,1);
    \draw[right] (5,4.5) node {\Large \bblue{quotation}};
  \draw[-triangle 45, very thick, color=red!80!black] (6,-1) .. controls
    (6,-2) and (5.5,-5.5) .. (3.5,-4);
    \draw[right] (5,-4.5) node {\Large \bred{evaluation}};
  \draw[-triangle 45, color=green!55!black] (7,0) .. controls 
    (8.5,.5) and (8.13,-2.13) .. (6.71,-.71);
    \draw[right] (7.9,-.4) node {\bgreen{alg}};
\end{tikzpicture}
\end{figure}
\vspace*{-1ex}

\bi

  \item[] \bblue{Advantages}: (1) $L_{\rm syn}$ resides in the logic
    and\\ (2) this approach scales up --- only one infrastructure is
    needed.

  \item[] \bblue{Disadvantage}: Requires a nontrivial modification of
    the logic.

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{MathScheme Framework}
\be

  \item Biform theories are used to combine axiomatic and algorithmic
    mathematical knowledge.

  \item Biform theories are expressed in a formal logic that supports
    \bgreen{undefinedness} and \bgreen{metareasoning with global
      reflection}.

  \bi

    \item Undefinedness: {\sc pf}, $\mbox{\sc pf}^*$, {\lutins}, {\nbgstar},
      {\stmm}, {\qzerou}.

    \item Quotation and evaluation: Chiron, {\qzerouqe}, {\churchqe},
      {\churchuqe}.

  \ei

  \item A body of mathematical knowledge is encoded as a \bgreen{graph of
    biform theories} using the little/tiny theories method.

  \item Algorithms are implemented as generic programs that are
    specialized using \bgreen{code generation}.

\ee
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Open Question}
\bi

  \item Can the little/tiny theories method be applied to biform
    theories?

  \item \bblue{Test case}: A graph of eight biform theories that encode
    natural number arithmetic and include a variety of transformers.

  \item We describe and compare two formalizations of the test case:

  \be

    \item In {\churchuqe} \bbrown{[Far17]} using \bred{global reflection}.

    \bi

      \item {\churchuqe} is a variant of {\churchqe}
        \bbrown{[Far16,Far16a]}, a version of Church's type theory
        with \bgreen{global quotation and evaluation operators}.

      \item {\churchuqe} includes a notion of a \bgreen{theory
        morphism}.

      \item {\churchuqe} and {\churchqe} are not yet implemented.

    \ei

    \item In Agda using \bred{local reflection}.

    \bi

      \item Agda is an implemented, \bgreen{dependently typed
        programming language}.

      \item Work is being done to add global reflection to Agda \bbrown{[WS12]}.

    \ei

  \ee

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Test Case: The Biform Theories}
\vspace{-2ex}
\footnotesize
\bc
\begin{tabular}{|l|l|l|l|l|l|}
\hline
& \textbf{Logic} & \textbf{Constants} & \textbf{Induction} & \textbf{Transformers} & \textbf{Decidability} \\ \hline \hline
\textbf{BT1} & FOL & $0,S$ & & IS-FO-BT1 & ${\sf undecidable}^*$\\ 
  & & & & & \\\hline
\textbf{BT2} & FOL & $0,S,+$ & & IS-FO-BT2, & ${\sf undecidable}^*$\\  
  & & & & BPLUS & \\\hline
\textbf{BT3} & FOL & $0,S,+,*$ & & IS-FO-BT3, & ${\sf undecidable}^*$\\  
  & & & & BTIMES & \\\hline
\textbf{BT4} & FOL & $0,S,+,*$ & $x = 0 \Orr {}$ & & essentially\\  
  & & & $\ForsomeApp y \mdot S(y) = x$ & & undecidable\\\hline
\textbf{BT5} & FOL & $0,S$ & induction & BT5-DEC-PROC & decidable\\  
  & & & schema & & \\\hline
\textbf{BT6} & FOL & $0,S,+$ & induction & BT6-DEC-PROC & decidable\\  
  & & & schema & & \\\hline
\textbf{BT7} & FOL & $0,S,+,*$ & induction &   & essentially \\  
  & & & schema & & undecidable\\\hline
\textbf{BT8} & STT & $0,S$ & induction & & essentially \\  
  & & & axiom & & undecidable\\\hline
\end{tabular}
\ec
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\vspace{-1ex}
\frametitle{Test Case: The Biform Theory Graph}
\bc
\begin{tikzpicture}[scale=2.8]
\node[thy] (bt1) at (0,0) {BT1};
\node[thy] (bt2) at (1,0) {BT2};
\node[thy] (bt3) at (2,0) {BT3};
\node[thy] (bt4) at (3,0) {BT4};
  \draw (3.1,-.2) node[below] {\parbox{12ex}{\borange{Robinson\\ Arithmetic}}};
\node[thy] (bt5) at (0,1) {BT5};
\node[thy] (bt6) at (1,1) {BT6};
  \draw (1.1,1.2) node[above] {\parbox{12ex}{\borange{Presburger\\ Arithmetic}}};
\node[thy] (bt7) at (2,1) {BT7};
  \draw (2.1,1.2) node[above] {\parbox{12ex}{\borange{First-Order\\ Peano\\ Arithmetic}}};
\node[thy] (bt8) at (3,1) {BT8};
  \draw (3.1,1.2) node[above] {\parbox{12ex}{\borange{Higher-Order Peano\\ Arithmetic}}};
\draw[inclusion-arrow] (bt1) to (bt2);
\draw[inclusion-arrow] (bt2) to (bt3);
\draw[inclusion-arrow] (bt3) to (bt4);
\draw[inclusion-arrow] (bt1) to (bt5);
\draw[inclusion-arrow] (bt2) to (bt6);
\draw[inclusion-arrow] (bt3) to (bt7);
\draw[inclusion-arrow] (bt5) to (bt6);
\draw[inclusion-arrow] (bt6) to (bt7);
\draw[view-arrow] (bt4) to (bt7);
\draw[view-arrow] (bt7) to (bt8);
\end{tikzpicture}
\ec
\vspace{-2ex}
The $\inclusion$ arrows denote theory inclusions.\\
The $\view$ arrows denote theory morphisms that are not inclusions.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{BT6 (Presburger Arithmetic) in {\churchqe} [1/5]}
\small
\bi

  \item[] \textbf{Primitive Base Types}

  \be

    \item $\iota$ (type of natural numbers).

  \ee

  \item[] \textbf{Primitive Constants}

  \be

    \item $0_\iota$.

    \item $S_{\iota \tarrow \iota}$.

    \item $+_{\iota \tarrow \iota \tarrow \iota}$ (infix).

    \item $\mname{BPLUS}_{\epsilon \tarrow \epsilon \tarrow \epsilon}$ (infix).

    \setcounter{enumi}{5}

    \item $\mname{BT6-DEC-PROC}_{\epsilon \tarrow \epsilon}$.

  \ee

  \item[] \textbf{Defined Constants (selected)}

  \be

    \item $1_\iota = S \, 0_\iota$.

  \ee

\ei

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{BT6 (Presburger Arithmetic) in {\churchqe} [2/5]}
\small
\vspace{-2ex}
\bi

  \item[] 

  \be

    \setcounter{enumi}{2}

    \item $\mname{bnat}_{\iota \tarrow \iota \tarrow \iota} =
      \LambdaApp x_\iota \mdot \LambdaApp y_\iota \mdot ((x_\iota +
      x_\iota) + y_\iota)$.
      
    Notational definition:

    \bi

      \item[] $(0)_2 = \mname{bnat} \, 0_\iota \, 0_\iota$.
  
      \item[] $(1)_2 = \mname{bnat} \, 0_\iota \, 1_\iota$.
  
      \item[] $(a_1 \cdots a_n0)_2 = \mname{bnat} \, (a_1 \cdots
        a_n)_2 \, 0_\iota$ {\sglsp} where each $a_i$ is 0 or 1.
  
      \item[] $(a_1 \cdots a_n1)_2 = \mname{bnat} \, (a_1 \cdots
        a_n)_2 \, 1_\iota$ {\sglsp} where each $a_i$ is 0 or 1.
  
    \ei

    \item $\mname{is-bnum}_{\epsilon \tarrow o} = 
      \IotaApp f_{\epsilon \tarrow o} \mdot
      \ForallApp \syn{u_\epsilon} \mdot
      (f_{\epsilon \tarrow \epsilon} \, \syn{u_\epsilon} \Iff {}\newline
      \hspace*{2ex}\ForsomeApp \syn{v_\epsilon} \mdot 
      \ForsomeApp \syn{w_\epsilon} \mdot
      (\syn{u_\epsilon} = \syn{\synbrack{\mname{bnat} \, 
      \commabrack{v_\epsilon} \, \commabrack{w_\epsilon}}} \Andd {}\newline
      \hspace*{4ex}(\syn{v_\epsilon} = \syn{\synbrack{0_\iota}} \Orr
      f_{\epsilon \tarrow \epsilon} \, \syn{v_\epsilon}) \Andd
      (\syn{w_\epsilon} = \syn{\synbrack{0_\iota}} \Orr
      \syn{w_\epsilon} =
      \syn{\synbrack{1_\iota}})))$.

    \item $\mname{IS-FO-BT2}_{\epsilon \tarrow \epsilon} = \LambdaApp
      x_\epsilon \mdot \textbf{B}_\epsilon$ {\sglsp} where
      $\textbf{B}_\epsilon$ is a complex expression such that
      $\syn{(\LambdaApp x_\epsilon \mdot \textbf{B}_\epsilon) \,
        \synbrack{\textbf{A}_\alpha}}$ equals $\syn{\synbrack{T_o}}$
      [$\syn{\synbrack{F_o}}$] if $\textbf{A}_\alpha$ is [not] a term
      or formula of first-order logic whose variables are of type
      $\iota$ and nonlogical constants are members of
      $\set{0_\iota,S_{\iota \tarrow \iota},+_{\iota \tarrow \iota
          \tarrow \iota}}$.

    \setcounter{enumi}{6}

    \item $\mname{IS-FO-BT2-ABS}_{\epsilon \tarrow \epsilon} = {}\newline
    \LambdaApp \syn{x_\epsilon} \mdot 
    (\If \; (\mname{is-abs}_{\epsilon \tarrow o} \, \syn{x_\epsilon}) \;
    \syn{(\mname{IS-FO-BT2}_{\epsilon \tarrow \epsilon} \,
    (\mname{abs-body}_{\epsilon \tarrow \epsilon} \, x_\epsilon))} \;
    \syn{\synbrack{F_o}})$.

  \ee

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{BT6 (Presburger Arithmetic) in {\churchqe} [3/5]}
\small
\bi

  \item[] \textbf{Axioms}

  \be

    \item $S \, x_\iota \not= 0_\iota$.

    \item $S \, x_\iota = S \, y_\iota \Implies x_\iota =
      y_\iota$.

    \item $x_\iota + 0_\iota = x_\iota$.

    \item $x_\iota + S \, y_\iota = S \, (x_\iota + y_\iota)$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies
      \syn{u_\epsilon \; \mname{BPLUS} \; \synbrack{(0)_2}} =
      \syn{u_\epsilon}$.

    \item[] $\vdots$

    \setcounter{enumi}{14}

    \item $(\mname{is-bnum} \, \syn{u_\epsilon} \Andd \mname{is-bnum}
      \, \syn{v_\epsilon}) \Implies {}\newline
        \hspace*{2ex} \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon} \, 1_\iota} \; \mname{BPLUS} \;
          \synbrack{\mname{bnat} \, \commabrack{v_\epsilon} \, 1_\iota}} = {}\newline
        \hspace*{2ex}\syn{\synbrack{\mname{bnat} \,
            \commabrack{(u_\epsilon \; \mname{BPLUS} \; v_\epsilon)
              \; \mname{BPLUS} \; \synbrack{(1)_2}} \, 0_\iota}}$.

    \setcounter{enumi}{28}

    \item Induction Schema for $S$ and $+$

    $\ForallApp \syn{f_\epsilon} \mdot 
    ((\mname{is-expr}_{\epsilon \tarrow o}^{\iota \tarrow o} \, \syn{f_\epsilon} \Andd
    \sembrack{\syn{\mname{IS-FO-BT2-ABS}_{\epsilon \tarrow \epsilon} \, 
    f_\epsilon}}_o) \Implies {} \newline
    \hspace*{2ex}((\sembrack{\syn{f_\epsilon}}_{\iota \tarrow o} \, 0_\iota \Andd
    (\ForallApp x_\iota \mdot 
    \sembrack{\syn{f_\epsilon}}_{\iota \tarrow o} \, x_\iota \Implies
    \sembrack{\syn{f_\epsilon}}_{\iota \tarrow o} \, 
    (\mname{S} \, x_\iota))) \Implies {}\newline
    \hspace*{4ex}\ForallApp x_\iota \mdot 
    \sembrack{\syn{f_\epsilon}}_{\iota \tarrow o} \, x_\iota))$.

  \ee

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{BT6 (Presburger Arithmetic) in {\churchqe} [4/5]}
\small
\vspace{-2ex}
\bi

  \item[]

  \be

    \setcounter{enumi}{28}

    \item Meaning formula for $\mname{BT6-DEC-PROC}_{\epsilon \tarrow \epsilon}$.

    $\ForallApp \syn{u_\epsilon} \mdot 
    ((\mname{is-expr}_{\epsilon \tarrow o}^{o} \, 
    \syn{u_\epsilon}  \Andd
    \mname{is-closed}_{\epsilon \tarrow o} \, \syn{u_\epsilon} \Andd 
    \sembrack{\syn{\mname{IS-FO-BT2}_{\epsilon \tarrow \epsilon} \, 
    u_\epsilon}}_o) \Implies {}\newline
    \hspace*{2ex}((\syn{\mname{BT6-DEC-PROC}_{\epsilon \tarrow \epsilon} \, u_\epsilon} = 
    \syn{\synbrack{T_o}} \Orr {}\newline
    \hspace*{3.9ex}\syn{\mname{BT6-DEC-PROC}_{\epsilon \tarrow \epsilon} \, u_\epsilon} = 
    \syn{\synbrack{F_o}}) \Andd {}\newline
    \hspace*{3.1ex}
    \sembrack{\syn{\mname{BT6-DEC-PROC}_{\epsilon \tarrow \epsilon} \, u_\epsilon}}_o =
    \sembrack{\syn{u_\epsilon}}_o))$.

  \ee

  \item[] \textbf{Transformers}

  \be

    \setcounter{enumi}{2}

    \item $\pi_3$ for $\mname{BPLUS}_{\epsilon \tarrow \epsilon
      \tarrow \epsilon}$ is an efficient program that satisfies Axioms
      5--15.

    \item $\pi_4$ for $\mname{BPLUS}_{\epsilon \tarrow \epsilon
      \tarrow \epsilon}$ uses Axioms 5--15 as conditional rewrite
      rules.

    \item $\pi_5$ for $\mname{IS-FO-BT2}_{\epsilon \tarrow
      \epsilon}$ is an efficient program that accesses the data
      stored in the data structures that represent expressions.

    \item $\pi_6$ for $\mname{IS-FO-BT2}_{\epsilon \tarrow \epsilon}$
      uses the definition of $\mname{IS-FO-BT2}_{\epsilon \tarrow
        \epsilon}$.

    \setcounter{enumi}{13}

    \item $\pi_{14}$ for $\mname{BT6-DEC-PROC}_{\epsilon \tarrow
      \epsilon \tarrow \epsilon}$ is an efficient decision procedure
      that satisfies Axiom 30.

  \ee

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{BT6 (Presburger Arithmetic) in {\churchqe} [5/5]}
\small
\vspace{-2ex}
\bi

  \item[]

  \be

    \setcounter{enumi}{14}

    \item $\pi_{15}$ for $\mname{IS-FO-BT2-ABS}_{\epsilon \tarrow
      \epsilon}$ is an efficient program that accesses the data stored
      in the data structures that represent expressions.

    \item $\pi_{16}$ for $\mname{IS-FO-BT2-ABS}_{\epsilon \tarrow
      \epsilon}$ uses the definition of
      $\mname{IS-FO-BT2-ABS}_{\epsilon \tarrow \epsilon}$.

  \ee

  \item[] \textbf{Theorems (selected)}

    \be

      \setcounter{enumi}{2}

      \item Meaning formula for 
      $\mname{BPLUS}_{\epsilon \tarrow \epsilon \tarrow \epsilon}$

      $\ForallApp \syn{u_\epsilon} \mdot \ForallApp \syn{v_\epsilon} \mdot
      ((\mname{is-bnum} \, \syn{u_\epsilon} \Andd \mname{is-bnum} \, \syn{v_\epsilon}) 
      \Implies {}\newline
      \hspace*{2ex}(\mname{is-bnum} \, 
      \syn{(u_\epsilon \; \mname{BPLUS} \; v_\epsilon)} \Andd {}\newline
      \hspace*{2.6ex}(\sembrack{\syn{u_\epsilon \; \mname{BPLUS} \; 
      v_\epsilon}}_\iota = 
      \sembrack{\syn{u_\epsilon}}_\iota + \sembrack{\syn{v_\epsilon}}_\iota)))$.

    \ee

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Notes: This is just like BT1 in CTT_uqe.  Also defines an injection
% from Agda's naturals (taken as syntax) to our interface to nat.
\begin{frame}[fragile]
\frametitle{BT1 in Agda}
\hspace*{-0.9cm}
\begin{minipage}{\textwidth}
{\footnotesize
\begin{code}%
\>\<%
\\
\>\AgdaKeyword{record} \AgdaRecord{BT₁} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{nat} \AgdaSymbol{:} \AgdaPrimitiveType{Set₀}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{Z} \AgdaSymbol{:} \AgdaField{nat}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{S} \AgdaSymbol{:} \AgdaField{nat} \AgdaSymbol{→} \AgdaField{nat}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{S≠Z} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaSymbol{→} \AgdaFunction{¬} \AgdaSymbol{(}\AgdaField{S} \AgdaBound{x} \AgdaDatatype{≡} \AgdaField{Z}\AgdaSymbol{)}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{inj} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaField{S} \AgdaBound{x} \AgdaDatatype{≡} \AgdaField{S} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{≡} \AgdaBound{y}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{One} \AgdaSymbol{:} \AgdaField{nat}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{One} \AgdaSymbol{=} \AgdaField{S} \AgdaField{Z}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦\_⟧₁} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaField{nat}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦} \AgdaNumber{0} \AgdaFunction{⟧₁} \AgdaSymbol{=} \AgdaField{Z}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦} \AgdaInductiveConstructor{suc} \AgdaBound{x} \AgdaFunction{⟧₁} \AgdaSymbol{=} \AgdaField{S} \AgdaFunction{⟦} \AgdaBound{x} \AgdaFunction{⟧₁}\<%
\end{code}
}
\end{minipage}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%

% Notes: in the local approach, need to define everything 'as
% syntax'.  binary digits are defined explicitly, and then
% binary numerals are defined as length>=1 strings of
% digits, written in low-to-high order (i.e. backwards).
% << is *2, and +1 is, well, + 1.
% finally actually define, as a total terminating function,
% bplus, which works on syntax.
%
% we can prove (see online code) the "meaning function"
% for bplus.
\begin{frame}[fragile]
\frametitle{Numerals in Agda}
\hspace*{-0.9cm}
\begin{minipage}{\textwidth}
{\scriptsize
\begin{code}%
\>\AgdaKeyword{data} \AgdaDatatype{BinDigit} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where} \AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{one} \AgdaSymbol{:} \AgdaDatatype{BinDigit}\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{BNum} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{bn} \AgdaSymbol{:}
\AgdaSymbol{\{}\AgdaBound{n} \AgdaSymbol{:}
\AgdaDatatype{ℕ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Vec}
\AgdaDatatype{BinDigit} \AgdaSymbol{(}\AgdaInductiveConstructor{suc}
\AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{BNum}\<%
\\
%
\\
\>\AgdaFunction{<<} \AgdaSymbol{:} \AgdaDatatype{BNum} \AgdaSymbol{→} \AgdaDatatype{BNum}\<%
\\
\>\AgdaFunction{<<} \AgdaSymbol{(}\AgdaInductiveConstructor{bn}
\AgdaBound{l}\AgdaSymbol{)} \AgdaSymbol{=}
\AgdaInductiveConstructor{bn}
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}
\AgdaInductiveConstructor{∷} \AgdaBound{l}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{+1} \AgdaSymbol{:} \AgdaDatatype{BNum} \AgdaSymbol{→} \AgdaDatatype{BNum}\<%
\\
\>\AgdaFunction{+1} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{(}\AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{∷} \AgdaBound{l}\AgdaSymbol{))} \AgdaSymbol{=} \AgdaInductiveConstructor{bn} \AgdaSymbol{(}\AgdaInductiveConstructor{one} \AgdaInductiveConstructor{∷} \AgdaBound{l}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{+1} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{(}\AgdaInductiveConstructor{one} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{))} \AgdaSymbol{=} \AgdaInductiveConstructor{bn} \AgdaSymbol{(}\AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{one} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{+1} \AgdaSymbol{(}\AgdaInductiveConstructor{bn}
\AgdaSymbol{(}\AgdaInductiveConstructor{one}
\AgdaInductiveConstructor{∷} \AgdaBound{x}
\AgdaInductiveConstructor{∷} \AgdaBound{l}\AgdaSymbol{))}
\AgdaSymbol{=} \AgdaFunction{<<} \AgdaSymbol{(}\AgdaFunction{+1}
\AgdaSymbol{(}\AgdaInductiveConstructor{bn}
\AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{∷}
\AgdaBound{l}\AgdaSymbol{)))}\<%
\\
%
\\
\>\AgdaFunction{bplus} \AgdaSymbol{:} \AgdaDatatype{BNum} \AgdaSymbol{→} \AgdaDatatype{BNum} \AgdaSymbol{→} \AgdaDatatype{BNum}\<%
\\
\>\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{\{}\AgdaNumber{0}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{))} \AgdaBound{y} \AgdaSymbol{=} \AgdaBound{y}\<%
\\
\>\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{\{}\AgdaNumber{0}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaInductiveConstructor{one} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{))} \AgdaBound{y} \AgdaSymbol{=} \AgdaFunction{+1} \AgdaBound{y}\<%
\\
\>\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{\{}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{d₀} \AgdaInductiveConstructor{∷} \AgdaBound{l₀}\AgdaSymbol{))} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{\{}\AgdaInductiveConstructor{ℕ.zero}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{))} \AgdaSymbol{=} \AgdaInductiveConstructor{bn} \AgdaSymbol{(}\AgdaBound{d₀} \AgdaInductiveConstructor{∷} \AgdaBound{l₀}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{\{}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{d₀} \AgdaInductiveConstructor{∷} \AgdaBound{l₀}\AgdaSymbol{))} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{\{}\AgdaInductiveConstructor{ℕ.zero}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaInductiveConstructor{one} \AgdaInductiveConstructor{∷} \AgdaInductiveConstructor{[]}\AgdaSymbol{))} \AgdaSymbol{=} \AgdaFunction{+1} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{(}\AgdaBound{d₀} \AgdaInductiveConstructor{∷} \AgdaBound{l₀}\AgdaSymbol{))}\<%
\\
\>\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn}
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}
\AgdaBound{n}\AgdaSymbol{\}}
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}
\AgdaInductiveConstructor{∷} \AgdaBound{l₀}\AgdaSymbol{))}
\AgdaSymbol{(}\AgdaInductiveConstructor{bn}
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}
\AgdaBound{m}\AgdaSymbol{\}}
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}
\AgdaInductiveConstructor{∷} \AgdaBound{l₁}\AgdaSymbol{))}
\AgdaSymbol{=} \AgdaFunction{<<} \AgdaSymbol{(}\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaBound{l₀}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaBound{l₁}\AgdaSymbol{))}\<%
\\
\>\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn}
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}
\AgdaBound{n}\AgdaSymbol{\}}
\AgdaSymbol{(}\AgdaInductiveConstructor{one}
\AgdaInductiveConstructor{∷} \AgdaBound{l₀}\AgdaSymbol{))}
\AgdaSymbol{(}\AgdaInductiveConstructor{bn}
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}
\AgdaBound{m}\AgdaSymbol{\}}
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}
\AgdaInductiveConstructor{∷} \AgdaBound{l₁}\AgdaSymbol{))}
\AgdaSymbol{=} \AgdaFunction{+1} \AgdaSymbol{(}\AgdaFunction{<<} \AgdaSymbol{(}\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaBound{l₀}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaBound{l₁}\AgdaSymbol{)))}\<%
\\
\>\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn}
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}
\AgdaBound{n}\AgdaSymbol{\}}
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}
\AgdaInductiveConstructor{∷} \AgdaBound{l₀}\AgdaSymbol{))}
\AgdaSymbol{(}\AgdaInductiveConstructor{bn}
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}
\AgdaBound{m}\AgdaSymbol{\}}
\AgdaSymbol{(}\AgdaInductiveConstructor{one}
\AgdaInductiveConstructor{∷} \AgdaBound{l₁}\AgdaSymbol{))}
\AgdaSymbol{=} \AgdaFunction{+1} \AgdaSymbol{(}\AgdaFunction{<<} \AgdaSymbol{(}\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaBound{l₀}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaBound{l₁}\AgdaSymbol{)))}\<%
\\
\>\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{\{}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaInductiveConstructor{one} \AgdaInductiveConstructor{∷} \AgdaBound{l₀}\AgdaSymbol{))} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaSymbol{\{}\AgdaInductiveConstructor{suc} \AgdaBound{m}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaInductiveConstructor{one} \AgdaInductiveConstructor{∷} \AgdaBound{l₁}\AgdaSymbol{))} \AgdaSymbol{=} \<[56]%
\>[56]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{+1} \AgdaSymbol{(}\AgdaFunction{+1} \AgdaSymbol{(}\AgdaFunction{<<} \AgdaSymbol{(}\AgdaFunction{bplus} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaBound{l₀}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{bn} \AgdaBound{l₁}\AgdaSymbol{))))}\<%
\end{code}
}
\end{minipage}
\end{frame}

%%%%%%%%%%%%%%%%%%

% Notes: Addition, bnat -- and an interpretation of binary numerals
% into the (base) nat.
\begin{frame}
\frametitle{BT2 in Agda}
\hspace*{-0.8cm}
\begin{minipage}{\textwidth}
{\footnotesize
\begin{code}%
\>\AgdaKeyword{record} \AgdaRecord{BT₂} \AgdaSymbol{(}\AgdaBound{t1} \AgdaSymbol{:} \AgdaRecord{BT₁}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{open} \AgdaModule{BT₁} \AgdaBound{t1} \AgdaKeyword{public}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{\_+\_} \AgdaSymbol{:} \AgdaFunction{nat} \AgdaSymbol{→} \AgdaFunction{nat} \AgdaSymbol{→} \AgdaFunction{nat}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{right-0} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaSymbol{→} \AgdaBound{x} \AgdaField{+} \AgdaFunction{Z} \AgdaDatatype{≡} \AgdaBound{x}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{x+Sy≡Sx+y} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{x} \AgdaField{+} \AgdaFunction{S} \AgdaBound{y} \AgdaDatatype{≡} \AgdaFunction{S} \AgdaSymbol{(}\AgdaBound{x} \AgdaField{+} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{bnat} \AgdaSymbol{:} \AgdaFunction{nat} \AgdaSymbol{→} \AgdaFunction{nat} \AgdaSymbol{→} \AgdaFunction{nat}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{bnat} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaBound{x} \AgdaField{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaField{+} \AgdaBound{y}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{dig-to-nat} \AgdaSymbol{:} \AgdaDatatype{BinDigit} \AgdaSymbol{→} \AgdaFunction{nat}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{dig-to-nat} \AgdaInductiveConstructor{zero} \AgdaSymbol{=} \AgdaFunction{Z}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{dig-to-nat} \AgdaInductiveConstructor{one} \AgdaSymbol{=} \AgdaFunction{S} \AgdaFunction{Z}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{unroll} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{n} \AgdaSymbol{:} \AgdaDatatype{ℕ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Vec} \AgdaDatatype{BinDigit} \AgdaBound{n} \AgdaSymbol{→} \AgdaFunction{nat}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{unroll} \AgdaInductiveConstructor{[]} \AgdaSymbol{=} \AgdaFunction{Z}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{unroll} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaBound{l}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{bnat} \AgdaSymbol{(}\AgdaFunction{unroll} \AgdaBound{l}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{dig-to-nat} \AgdaBound{x}\AgdaSymbol{)}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦\_⟧₂} \AgdaSymbol{:} \AgdaDatatype{BNum} \AgdaSymbol{→} \AgdaFunction{nat}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦} \AgdaInductiveConstructor{bn} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{∷} \AgdaBound{l}\AgdaSymbol{)} \AgdaFunction{⟧₂} \AgdaSymbol{=} \AgdaFunction{bnat} \AgdaSymbol{(}\AgdaFunction{unroll} \AgdaBound{l}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{dig-to-nat} \AgdaBound{x}\AgdaSymbol{)}\<%
\\
\end{code}
}
\end{minipage}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%

% Notes:
% - Ground language: a 'language' (with decidable equality), and
% evaluation
% - LogicOverL: a 'Logic' (seen as a language), and an interpretation
% back into the host
% - FOL: definition of FOL over any ground language (see _==_ )
\begin{frame}
\frametitle{Language infrastructure}
\hspace*{-1.3cm}
\begin{minipage}{\textwidth}
{\scriptsize
\begin{code}%
\>\AgdaKeyword{record} \AgdaRecord{GroundLanguage} \AgdaSymbol{(}\AgdaBound{T} \AgdaSymbol{:} \AgdaPrimitiveType{Set₀}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{Lang} \AgdaSymbol{:} \AgdaFunction{DT} \AgdaSymbol{→} \AgdaPrimitiveType{Set₀}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{value} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{V}
\AgdaSymbol{:} \AgdaFunction{DT}\AgdaSymbol{\}} \AgdaSymbol{→}
\AgdaField{Lang} \AgdaBound{V} \AgdaSymbol{→}
\AgdaSymbol{(}\AgdaField{Carrier} \AgdaBound{V} \AgdaSymbol{→}
\AgdaBound{T}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{T}\<%
\\
%
\\
\>\AgdaKeyword{record} \AgdaRecord{LogicOverL} \AgdaSymbol{(}\AgdaBound{T} \AgdaSymbol{:} \AgdaPrimitiveType{Set₀}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{L} \AgdaSymbol{:} \AgdaRecord{GroundLanguage} \AgdaBound{T}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{Logic} \AgdaSymbol{:} \AgdaFunction{DT} \AgdaSymbol{→} \AgdaPrimitiveType{Set₀}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧\_} \AgdaSymbol{:} \AgdaSymbol{∀}
\AgdaSymbol{\{}\AgdaBound{V}\AgdaSymbol{\}} \AgdaSymbol{→}
\AgdaField{Logic} \AgdaBound{V} \AgdaSymbol{→}
\AgdaSymbol{(}\AgdaField{Carrier} \AgdaBound{V} \AgdaSymbol{→}
\AgdaBound{T}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaPrimitiveType{Set₀}\<%
\\
%
\\
\>\AgdaKeyword{module} \AgdaModule{FOL} \AgdaSymbol{\{}\AgdaBound{T} \AgdaSymbol{:} \AgdaPrimitiveType{Set₀}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{L} \AgdaSymbol{:} \AgdaRecord{GroundLanguage} \AgdaBound{T}\AgdaSymbol{)} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{data} \AgdaDatatype{FOL} \AgdaSymbol{(}\AgdaBound{V} \AgdaSymbol{:} \AgdaFunction{DT}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{tt} \AgdaSymbol{:} \AgdaDatatype{FOL} \AgdaBound{V}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{ff} \AgdaSymbol{:} \AgdaDatatype{FOL} \AgdaBound{V}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{\_and\_} \AgdaSymbol{:} \AgdaDatatype{FOL} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{\_or\_} \AgdaSymbol{:} \AgdaDatatype{FOL} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{not} \AgdaSymbol{:} \AgdaDatatype{FOL} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{\_⊃\_} \AgdaSymbol{:} \AgdaDatatype{FOL} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{\_==\_} \AgdaSymbol{:} \AgdaField{Lang} \AgdaBound{V} \AgdaSymbol{→} \AgdaField{Lang} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{all} \AgdaSymbol{:} \AgdaField{Carrier} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{exist} \AgdaSymbol{:} \AgdaField{Carrier} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{V}\<%
\end{code}
}
\end{minipage}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%

% Notes: Need to *interpret* our terms of classical logic into the
% host logic.  As it is constructive, need double-negation embedding
\begin{frame}
\frametitle{Logic over a Language, back into Agda}
\hspace*{-1.8cm}
\begin{minipage}{\textwidth}
{\footnotesize
\begin{code}%
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{LoL-FOL} \AgdaSymbol{:} \AgdaRecord{LogicOverL} \AgdaBound{T} \AgdaBound{L}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{LoL-FOL} \AgdaSymbol{=} \AgdaKeyword{record} \AgdaSymbol{\{} \AgdaField{Logic} \AgdaSymbol{=} \AgdaDatatype{FOL} \AgdaSymbol{;} \AgdaField{⟦\_⟧\_} \AgdaSymbol{=} \AgdaFunction{interp} \AgdaSymbol{\}}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaKeyword{where}\<%
\\
\>[3]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{interp} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Var} \AgdaSymbol{:} \AgdaFunction{DT}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{Var} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaField{Carrier} \AgdaBound{Var} \AgdaSymbol{→} \AgdaBound{T}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaPrimitiveType{Set₀}\<%
\\
\>[3]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{interp} \AgdaInductiveConstructor{tt} \AgdaBound{env} \AgdaSymbol{=} \AgdaRecord{⊤}\<%
\\
\>[3]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{interp} \AgdaInductiveConstructor{ff} \AgdaBound{env} \AgdaSymbol{=} \AgdaDatatype{⊥}\<%
\\
\>[3]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{interp} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{and} \AgdaBound{f}\AgdaSymbol{)} \AgdaBound{env} \AgdaSymbol{=} \AgdaFunction{interp} \AgdaBound{e} \AgdaBound{env} \AgdaFunction{×} \AgdaFunction{interp} \AgdaBound{f} \AgdaBound{env}\<%
\\
\>[3]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{interp} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{or} \AgdaBound{f}\AgdaSymbol{)} \AgdaBound{env} \AgdaSymbol{=} \AgdaFunction{¬} \AgdaFunction{¬} \AgdaSymbol{(}\AgdaFunction{interp} \AgdaBound{e} \AgdaBound{env} \AgdaDatatype{⊎} \AgdaFunction{interp} \AgdaBound{f} \AgdaBound{env}\AgdaSymbol{)}\<%
\\
\>[3]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{interp} \AgdaSymbol{(}\AgdaInductiveConstructor{not} \AgdaBound{e}\AgdaSymbol{)} \AgdaBound{env} \AgdaSymbol{=} \AgdaFunction{¬} \AgdaSymbol{(}\AgdaFunction{interp} \AgdaBound{e} \AgdaBound{env}\AgdaSymbol{)}\<%
\\
\>[3]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{interp} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{⊃} \AgdaBound{f}\AgdaSymbol{)} \AgdaBound{env} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaFunction{interp} \AgdaBound{e} \AgdaBound{env}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaFunction{interp} \AgdaBound{f} \AgdaBound{env}\AgdaSymbol{)}\<%
\\
\>[3]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{interp} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{==} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{env} \AgdaSymbol{=} \AgdaField{value} \AgdaBound{x} \AgdaBound{env} \AgdaDatatype{≡} \AgdaField{value} \AgdaBound{y} \AgdaBound{env}\<%
\\
\>[3]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{interp} \AgdaSymbol{\{}\AgdaBound{V}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaInductiveConstructor{all} \AgdaBound{x} \AgdaBound{p}\AgdaSymbol{)} \AgdaBound{env} \<[31]%
\>[31]\AgdaSymbol{=} \AgdaSymbol{∀} \AgdaBound{z} \AgdaSymbol{→} \AgdaFunction{interp} \AgdaBound{p} \AgdaSymbol{(}\AgdaFunction{override} \AgdaSymbol{\{}\AgdaBound{V}\AgdaSymbol{\}} \AgdaBound{env} \AgdaBound{x} \AgdaBound{z}\AgdaSymbol{)}\<%
\\
\>[3]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{interp} \AgdaSymbol{\{}\AgdaBound{V}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaInductiveConstructor{exist} \AgdaBound{x} \AgdaBound{p}\AgdaSymbol{)} \AgdaBound{env} \AgdaSymbol{=} \AgdaFunction{¬} \AgdaFunction{¬} \AgdaSymbol{(}\AgdaRecord{Σ} \AgdaBound{T} \AgdaSymbol{(λ} \AgdaBound{t} \AgdaSymbol{→} \AgdaFunction{interp} \AgdaBound{p} \AgdaSymbol{(}\AgdaFunction{override} \AgdaSymbol{\{}\AgdaBound{V}\AgdaSymbol{\}} \AgdaBound{env} \AgdaBound{x} \AgdaBound{t}\AgdaSymbol{)))}\<%
\end{code}
}
\end{minipage}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{BT6 (Presburger Arithmetic) in Agda}
\hspace*{-1.3cm}
\begin{minipage}{\textwidth}
{\footnotesize
\begin{code}%
\>\AgdaKeyword{record} \AgdaRecord{BT₆} \AgdaSymbol{\{}\AgdaBound{t₁} \AgdaSymbol{:} \AgdaRecord{BT₁}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{t₂} \AgdaSymbol{:} \AgdaRecord{BT₂} \AgdaBound{t₁}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{t₅} \AgdaSymbol{:} \AgdaRecord{BT₅} \AgdaBound{t₁}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{open} \AgdaModule{VarLangs} \AgdaKeyword{using} \AgdaSymbol{(}\AgdaFunction{XV}\AgdaSymbol{;} \AgdaInductiveConstructor{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{open} \AgdaModule{DecSetoid} \AgdaKeyword{using} \AgdaSymbol{(}\AgdaField{Carrier}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{open} \AgdaModule{BT₂} \AgdaBound{t₂} \AgdaKeyword{public}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{open} \AgdaModule{fo₂} \AgdaKeyword{using} \AgdaSymbol{(}\AgdaDatatype{FOL}\AgdaSymbol{;} \AgdaInductiveConstructor{tt}\AgdaSymbol{;} \AgdaInductiveConstructor{ff}\AgdaSymbol{;} \AgdaFunction{LoL-FOL}\AgdaSymbol{;} \AgdaInductiveConstructor{\_and\_}\AgdaSymbol{;} \AgdaInductiveConstructor{all}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{open} \AgdaModule{LogicOverL} \AgdaFunction{LoL-FOL}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{induct} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{e} \AgdaSymbol{:} \AgdaDatatype{FOL} \AgdaFunction{XV}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{⟦} \AgdaBound{e} \AgdaFunction{⟧} \AgdaSymbol{(λ} \AgdaSymbol{\{} \AgdaInductiveConstructor{x} \AgdaSymbol{→} \AgdaFunction{⟦} \AgdaNumber{0} \AgdaFunction{⟧₁} \AgdaSymbol{\})} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(∀} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{⟦} \AgdaBound{e} \AgdaFunction{⟧} \AgdaSymbol{(λ} \AgdaSymbol{\{}\AgdaInductiveConstructor{x} \AgdaSymbol{→} \AgdaBound{y}\AgdaSymbol{\})} \AgdaSymbol{→} \AgdaFunction{⟦} \AgdaBound{e} \AgdaFunction{⟧} \AgdaSymbol{(λ} \AgdaSymbol{\{}\AgdaInductiveConstructor{x} \AgdaSymbol{→} \AgdaFunction{S} \AgdaBound{y}\AgdaSymbol{\}))} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{∀} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{⟦} \AgdaBound{e} \AgdaFunction{⟧} \AgdaSymbol{(λ} \AgdaSymbol{\{}\AgdaInductiveConstructor{x} \AgdaSymbol{→} \AgdaBound{y}\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{postulate}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaPostulate{decide} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{W}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaField{Carrier} \AgdaBound{W} \AgdaSymbol{→} \AgdaFunction{nat}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaBound{W} \AgdaSymbol{→} \AgdaDatatype{FOL} \AgdaFunction{NoVars}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaPostulate{meaning-decide} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{W} \AgdaSymbol{:} \AgdaFunction{DT}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{env} \AgdaSymbol{:} \AgdaField{Carrier} \AgdaBound{W} \AgdaSymbol{→} \AgdaFunction{nat}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{env′} \AgdaSymbol{:} \AgdaDatatype{⊥} \AgdaSymbol{→} \AgdaFunction{nat}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{e} \AgdaSymbol{:} \AgdaDatatype{FOL} \AgdaBound{W}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaKeyword{let} \AgdaBound{res} \AgdaSymbol{=} \AgdaPostulate{decide} \AgdaBound{env} \AgdaBound{e} \AgdaKeyword{in}\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{res} \AgdaDatatype{≡} \AgdaInductiveConstructor{tt} \AgdaDatatype{⊎} \AgdaBound{res} \AgdaDatatype{≡} \AgdaInductiveConstructor{ff}\AgdaSymbol{)} \AgdaFunction{×} \AgdaSymbol{(}\AgdaFunction{⟦} \AgdaBound{e} \AgdaFunction{⟧} \AgdaBound{env}\AgdaSymbol{)} \AgdaRecord{≃} \AgdaSymbol{(}\AgdaFunction{⟦} \AgdaBound{res} \AgdaFunction{⟧} \AgdaBound{env′}\AgdaSymbol{)}\<%
\end{code}
}
\end{minipage}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}
\frametitle{Conclusion}
\bi

  \item We have proposed a biform theory graph test case encoding
    natural number arithmetic and including various transformers.

\pause

  \item We have formalized the test case in (1) {\churchuqe} using 
    global reflection and (2) Agda using the local reflection.

  \bi

    \item We have obtain substantial partial formalizations that
      indicate full formalizations could be obtain with additional
      work.

  \ei

\pause

  \item Our results show that the global approach has a significant
    advantage over the local approach ---

  \bi

    \item[] since the local approach requires a separate
      infrastructure for each set of expressions manipulated by a
      transformer.
 
  \ei

\pause

  \item We recommend that future research be directed to making the
    global approach practical for formalizing biform theories.

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}\label{lastframe}
\frametitle{References}
\scriptsize
\bi

  \item \bbrown{[WS12]} P. van der Walt and W. Swierstra,
    ``Engineering proof by reflection in Agda'', in:
    \emph{Implementation and Application of Functional Languages},
    LNCS~8241:157--173, 2012.

  \item \bbrown{[CF08]} J. Carette and W. M. Farmer, ``High-level
    theories'', in: \emph{Intelligent Computer Mathematics}, LNCS
    5144:232--245, 2008.

  \item \bbrown{[CFO11]} J. Carette, W. M. Farmer, and R. O'Connor,
    ``MathScheme: Project description'', in: \emph{Intelligent
    Computer Mathematics}, LNCS~6824:287--288, 2011.

  \item \bbrown{[Far16]} W. M. Farmer, ``Incorporating quotation and
    evaluation into Church's type theory: Syntax and semantics'', in:
    \emph{Intelligent Computer Mathematics}, LNCS 9791:83--98, 2016

  \item \bbrown{[Far16a]} W. M. Farmer, ``Incorporating quotation and
    evaluation into Church's type theory'', in: CoRR, abs/1612.02785
    (72 pp.), 2016.

  \item \bbrown{[Far17]} W. M. Farmer, ``Theory morphisms in Church's
    type theory with quotation and evaluation'', in: \emph{Intelligent
      Computer Mathematics}, LNCS 10383, 16~pp., 2017.

  \item \bbrown{[FGT92]} W. M. Farmer, J. D. Guttman, and
    F. J. Thayer, ``Little theories'', in: \emph{Automated Deduction
      --- CADE-11}, LNCS 607:567--581, 1992.

  \item \bbrown{[FM03]} W. M. Farmer and M. von Mohrenschildt, ``An
    overview of a Formal Framework for Managing Mathematics'', Annals
    of Mathematics and Artificial Intelligence 38:165--191, 2003.

  \item \bbrown{[Kol14]} M. Kohlhase, ``Mathematical knowledge
    management: Transcending the one-brain-barrier with theory
    graphs'', EMS Newletter 92:22--27, 2014.

\ei
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse

\begin{frame}
\frametitle{}
\bi

  \item 

\ei
\end{frame}

\fi

\end{document}
