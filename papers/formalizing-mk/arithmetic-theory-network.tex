\documentclass[fleqn,11pt]{article}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{color}
\usepackage{url}
\usepackage{phonetic}
\usepackage{amsmath}

\input{arithmetic-theory-network-def}

\title{{\bf A Network of Arithmetic Biform Theories}}

\author{William M. Farmer}

\date{\today}

\begin{document}

\maketitle

\section{Introduction}

This report describes a network of arithmetic biform theories
expressed in {\churchqe}~\cite{FarmerArxiv16}, a version of simple
type theory with quotation and evaluation.  The reader is expected to
be familiar with the notation of {\churchqe}.  The following are
additional notes to the reader:

\be

  \item We assume that a denumerable set of unspecified base types and
    a definite description operator $\Iota$ have been added to
    {\churchqe}.

  \item All constants that are not introduced as components of one of
    the biform theories listed below are logical constants of
    {\churchqe}, either primitive or defined.
    $\mname{is-abs}_{\epsilon \tarrow o}$, $\mname{abs-body}_{\epsilon
      \tarrow \epsilon}$, and $\mname{is-closed}_{\epsilon \tarrow o}$
    are defined logical constants not in~\cite{FarmerArxiv16}.
    $\mname{is-abs}_{\epsilon \tarrow o} \, \textbf{A}_\epsilon$ holds
    iff $\textbf{A}_\epsilon$ represents an abstraction.  If
    $\textbf{A}_\epsilon$ represents an abstraction, then
    $\mname{abs-body}_{\epsilon \tarrow \epsilon} \,
    \textbf{A}_\epsilon$ represents the body of the abstraction.
    $\mname{is-closed}_{\epsilon \tarrow o} \, \textbf{A}_\epsilon$
    holds iff $\textbf{A}_\epsilon$ represents an expression that is
    closed (and eval-free).

  \item The type attached to a constant may be dropped when there is
    no loss of meaning.

  \item When it makes sense, the notation
    $\set{\textbf{A}_{\alpha}^{1}, \ldots, \textbf{A}_{\alpha}^{n}}$
    denotes the predicate
    \[\LambdaApp \textbf{x}_\alpha \mdot 
    (\textbf{x}_\alpha = \textbf{A}_{\alpha}^{1} \Or \cdots \Or
    \textbf{x}_\alpha = \textbf{A}_{\alpha}^{n}).\]

  \item Expressions of type $\epsilon$, i.e., expressions that denote
    constructions, are colored red.

\ee
  

\section{Biform Theories}

\noindent
\textbf{T1: Simple Theory of Successor}

\bi

  \item[] \textbf{Base Types} 

  \be

    \item \mname{nat}.

  \ee

  \item[] \textbf{Primitive Constants}

  \be

    \item $0_{\sf nat}$.

    \item $S_{{\sf nat} \tarrow {\sf nat}}$.

  \ee

  \item[] \textbf{Defined Constants}

  \be

    \item $1_{\sf nat} = S \, 0$.

    \item $\mname{is-fo-T1}_{\epsilon \tarrow \epsilon} = \LambdaApp
      x_\epsilon \mdot \textbf{B}_\epsilon$ {\sglsp} where
      $\textbf{B}_\epsilon$ is a complex expression such that
      $\syn{(\LambdaApp x_\epsilon \mdot \textbf{B}_\epsilon) \,
      \synbrack{\textbf{A}_o}}$ equals $\syn{\synbrack{T_o}}$
      [$\syn{\synbrack{F_o}}$] if $\textbf{A}_o$ is [not] a formula of
      first-order logic with equality whose variables are of type
      $\mname{nat}$ and whose nonlogical constants are members of
      $\set{0,S}$.

  \ee

  \item[] \textbf{Axioms}

  \be

    \item $S \, x_{\sf nat} \not= 0$.

    \item $S \, x_{\sf nat} = S \, y_{\sf nat} \Implies x_{\sf nat} =
      y_{\sf nat}$.

  \ee

  \item[] \textbf{Transformers}

  \be

    \item $\xi_1$ computes $\mname{is-fo-T1}_{\epsilon \tarrow
      \epsilon}$ using an efficient program that accesses the data
      stored in the data structures that represent expressions.

    \item $\xi_2$ computes $\mname{is-fo-T1}_{\epsilon \tarrow
      \epsilon}$ using its definition.

  \ee

\ei

\noindent
\textbf{T2: Simple Theory of Successor and Addition}

\bi

  \item[] \textbf{Extended Theories} 

  \be

    \item T1.

  \ee


  \item[] \textbf{Primitive Constants}

  \be

    \setcounter{enumi}{2}

    \item $+_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}}$ (infix).

    \item $\mname{bplus}_{\epsilon \tarrow \epsilon \tarrow \epsilon}$ (infix).

  \ee

  \item[] \textbf{Defined Constants}

  \be

    \setcounter{enumi}{2}

    \item $\mname{bnat}_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf
        nat}} = \LambdaApp x_{\sf nat} \mdot \LambdaApp y_{\sf nat}
      \mdot ((x_{\sf nat} + x_{\sf nat}) + y_{\sf nat})$.
      
    Notational definition:

    \bi

      \item[] $(0)_2 = \mname{bnat} \, 0_{\sf nat} \, 0_{\sf nat}$.
  
      \item[] $(1)_2 = \mname{bnat} \, 0_{\sf nat} \, 1_{\sf nat}$.
  
      \item[] $(a_1 \cdots a_n0)_2 = \mname{bnat} \, (a_1 \cdots
        a_n)_2 \, 0_{\sf nat}$ {\sglsp} where each $a_i$ is 0 or 1.
  
      \item[] $(a_1 \cdots a_n1)_2 = \mname{bnat} \, (a_1 \cdots
        a_n)_2 \, 1_{\sf nat}$ {\sglsp} where each $a_i$ is 0 or 1.
  
    \ei

    \item $\mname{is-bnum}_{\epsilon \tarrow o} = 
      \IotaApp f_{\epsilon \tarrow o} \mdot
      \ForallApp \syn{u_\epsilon} \mdot
      (f_{\epsilon \tarrow \epsilon} \, \syn{u_\epsilon} \Iff {}\\
      \hspace*{2ex}\ForsomeApp \syn{v_\epsilon} \mdot 
      \ForsomeApp \syn{w_\epsilon} \mdot
      (\syn{u_\epsilon} = \syn{\synbrack{\mname{bnat} \, 
      \commabrack{v_\epsilon} \, \commabrack{w_\epsilon}}} \And {}\\
      \hspace*{4ex}(\syn{v_\epsilon} = \syn{\synbrack{0}} \Or 
      f_{\epsilon \tarrow \epsilon} \, \syn{v_\epsilon}) \And
      (\syn{w_\epsilon} = \syn{\synbrack{0}} \Or 
      \syn{w_\epsilon} = \syn{\synbrack{1}})))$.

    \item $\mname{is-fo-T2}_{\epsilon \tarrow \epsilon} = \LambdaApp
      x_\epsilon \mdot \textbf{B}_\epsilon$ {\sglsp} where
      $\textbf{B}_\epsilon$ is a complex expression such that
      $\syn{(\LambdaApp x_\epsilon \mdot \textbf{B}_\epsilon) \,
        \synbrack{\textbf{A}_o}}$ equals $\syn{\synbrack{T_o}}$
      [$\syn{\synbrack{F_o}}$] if $\textbf{A}_o$ is [not] a formula of
      first-order logic with equality whose variables are of type
      $\mname{nat}$ and whose nonlogical constants are members of
      $\set{0,S,+}$.
      
  \ee

  \item[] \textbf{Axioms}

  \be

    \setcounter{enumi}{4}

    \item $x_{\sf nat} + 0 = x_{\sf nat}$.

    \item $x_{\sf nat} + S \, y_{\sf nat} = S \, (x_{\sf nat} + y_{\sf
      nat})$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies
      \syn{u_\epsilon \; \mname{bplus} \; \synbrack{(0)_2}} =
      \syn{u_\epsilon}$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies
      \syn{\synbrack{(0)_2} \; \mname{bplus} \; u_\epsilon} =
      \syn{u_\epsilon}$.

    \item $\syn{\synbrack{(1)_2} \; \mname{bplus} \;
      \synbrack{(1)_2}} = \syn{\synbrack{(10)_2}}$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies {}\\
        \hspace*{2ex} \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon} \, 0} \; \mname{bplus} \;
          \synbrack{(1)_2}} = \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon} \, 1}}$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies {}\\
        \hspace*{2ex} \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon} \, 1} \; \mname{bplus} \;
          \synbrack{(1)_2}} = \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon \; \mname{bplus} \;
              \synbrack{(1)_2}} \, 0}}$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies {}\\
        \hspace*{2ex} \syn{\synbrack{(1)_2} \; \mname{bplus} \;
          \synbrack{\mname{bnat} \, \commabrack{u_\epsilon} \, 0}} =
        \syn{\synbrack{\mname{bnat} \, \commabrack{u_\epsilon} \,
            1}}$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies {}\\
        \hspace*{2ex} \syn{\synbrack{(1)_2} \; \mname{bplus} \;
          \synbrack{\mname{bnat} \, \commabrack{u_\epsilon} \, 0}} =
        \syn{\synbrack{\mname{bnat} \, \commabrack{u_\epsilon \;
              \mname{bplus} \; \synbrack{(1)_2}} \, 0}}$.

    \item $(\mname{is-bnum} \, \syn{u_\epsilon} \And \mname{is-bnum}
      \, \syn{v_\epsilon}) \Implies {}\\
        \hspace*{2ex} \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon} \, 0} \; \mname{bplus} \;
          \synbrack{\mname{bnat} \, \commabrack{v_\epsilon} 0}} =
        \syn{\synbrack{\mname{bnat} \, \commabrack{u_\epsilon \;
              \mname{bplus} \; v_\epsilon} \, 0}}$.

    \item $(\mname{is-bnum} \, \syn{u_\epsilon} \And \mname{is-bnum}
      \, \syn{v_\epsilon}) \Implies {}\\
        \hspace*{2ex} \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon} \, 0} \; \mname{bplus} \;
          \synbrack{\mname{bnat} \, \commabrack{v_\epsilon} \, 1}} =
        \syn{\synbrack{\mname{bnat} \, \commabrack{u_\epsilon \;
              \mname{bplus} \; v_\epsilon} \, 1}}$.

    \item $(\mname{is-bnum} \, \syn{u_\epsilon} \And \mname{is-bnum}
      \, \syn{v_\epsilon}) \Implies {}\\
        \hspace*{2ex} \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon} \, 1} \; \mname{bplus} \;
          \synbrack{\mname{bnat} \, \commabrack{v_\epsilon} \, 0}} =
        \syn{\synbrack{\mname{bnat} \, \commabrack{u_\epsilon \;
              \mname{bplus} \; v_\epsilon} \, 1}}$.

    \item $(\mname{is-bnum} \, \syn{u_\epsilon} \And \mname{is-bnum}
      \, \syn{v_\epsilon}) \Implies {}\\
        \hspace*{2ex} \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon} \, 1} \; \mname{bplus} \;
          \synbrack{\mname{bnat} \, \commabrack{v_\epsilon} \, 1}} = {}\\
        \hspace*{2ex}\syn{\synbrack{\mname{bnat} \,
            \commabrack{(u_\epsilon \; \mname{bplus} \; v_\epsilon)
              \; \mname{bplus} \; \synbrack{(1)_2}} \, 0}}$.

  \ee

  \item[] \textbf{Transformers}

  \be

      \setcounter{enumi}{2}

    \item $\xi_3$ computes $\mname{bplus}_{\epsilon \tarrow \epsilon
      \tarrow \epsilon}$ using an efficient program that
      satisfies Axioms 7--17.

    \item $\xi_4$ computes $\mname{bplus}_{\epsilon \tarrow \epsilon
      \tarrow \epsilon}$ using Axioms 7--17 as conditional rewrite
      rules.

    \item $\xi_5$ computes $\mname{is-fo-T1}_{\epsilon \tarrow
      \epsilon}$ using an efficient program that accesses the data
      stored in the data structures that represent expressions.

    \item $\xi_6$ computes $\mname{is-fo-T2}_{\epsilon \tarrow
      \epsilon}$ using its definition.

  \ee
    
  \item[] \textbf{Theorems}

    \be

      \setcounter{enumi}{0}

      \item Meaning formula schema for 
      $\mname{bplus}_{\epsilon \tarrow \epsilon \tarrow \epsilon}$

      $((\mname{is-bnum} \, \syn{\textbf{A}_\epsilon} \And 
      \mname{is-bnum} \, \syn{\textbf{B}_\epsilon}) 
      \Implies {}\\
      \hspace*{2ex}(\mname{is-bnum} \, 
      \syn{(\textbf{A}_\epsilon \; \mname{bplus} \; \textbf{B}_\epsilon)} \And {}\\
      \hspace*{2.8ex}(\sembrack{\syn{\textbf{A}_\epsilon \; \mname{bplus} \; 
      \textbf{B}_\epsilon}}_{\sf nat} = 
      \sembrack{\syn{\textbf{A}_\epsilon}}_{\sf nat} + 
      \sembrack{\syn{\textbf{B}_\epsilon}}_{\sf nat})))$.

    \ee

\ei

\noindent
\textbf{T3: Simple Theory of Successor, Addition, and Multiplication}

\bi

  \item[] \textbf{Extended Theories} 

  \be

    \setcounter{enumi}{1}

    \item T2.

  \ee

  \item[] \textbf{Primitive Constants}

  \be

    \setcounter{enumi}{4}

    \item $*_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}}$ (infix).

    \item $\mname{btimes}_{\epsilon \tarrow \epsilon \tarrow \epsilon}$ (infix).

  \ee

  \item[] \textbf{Defined Constants}

  \be

    \setcounter{enumi}{3}

    \item $\mname{is-fo-T3}_{\epsilon \tarrow \epsilon} = \LambdaApp
      x_\epsilon \mdot \textbf{B}_\epsilon$ {\sglsp} where
      $\textbf{B}_\epsilon$ is a complex expression such that
      $\syn{(\LambdaApp x_\epsilon \mdot \textbf{B}_\epsilon) \,
      \synbrack{\textbf{A}_o}}$ equals $\syn{\synbrack{T_o}}$
      [$\syn{\synbrack{F_o}}$] if $\textbf{A}_o$ is [not] a formula of
      first-order logic with equality whose variables are of type
      $\mname{nat}$ and whose nonlogical constants are members of
      $\set{0,S,+,*}$.

  \ee

  \item[] \textbf{Axioms}

  \be

    \setcounter{enumi}{17}

    \item $x_{\sf nat} * 0 = 0$.

    \item $x_{\sf nat} * S \, y_{\sf nat} = (x_{\sf nat} * y_{\sf
      nat}) + x_{\sf nat}$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies
      \syn{u_\epsilon \; \mname{btimes} \; \synbrack{(0)_2}} =
      \syn{\synbrack{(0)_2}}$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies \syn{
      \synbrack{(0)_2} \; \mname{btimes} \; u_\epsilon} =
      \syn{\synbrack{(0)_2}}$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies
      \syn{u_\epsilon \; \mname{btimes} \; \synbrack{(1)_2}} =
      \syn{u_\epsilon}$.

    \item $\mname{is-bnum} \, \syn{u_\epsilon} \Implies
      \syn{\synbrack{(1)_2} \; \mname{btimes} \; u_\epsilon} =
      \syn{u_\epsilon}$.

    \item $(\mname{is-bnum} \, \syn{u_\epsilon} \And \mname{is-bnum}
      \, \syn{v_\epsilon}) \Implies {}\\
        \hspace*{2ex} \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon} \, 0} \; \mname{btimes} \;
          \syn{v_\epsilon}} = \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon \; \mname{btimes} \; v_\epsilon} \,
            0}}$.

    \item $(\mname{is-bnum} \, \syn{u_\epsilon} \And \mname{is-bnum}
      \, \syn{v_\epsilon}) \Implies {}\\
        \hspace*{2ex} \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon} \, 1} \; \mname{btimes} \;
          \syn{v_\epsilon}} = \syn{\synbrack{\mname{bnat} \,
            \commabrack{u_\epsilon \; \mname{btimes} \; v_\epsilon} \,
            0} \; \mname{badd} \; v_\epsilon}$.

    \item $(\mname{is-bnum} \, \syn{u_\epsilon} \And \mname{is-bnum}
      \, \syn{v_\epsilon}) \Implies {}\\
        \hspace*{2ex} \syn{\syn{v_\epsilon}\; \mname{btimes} \;
          \synbrack{\mname{bnat} \, \commabrack{u_\epsilon} \, 0}} =
        \syn{\synbrack{\mname{bnat} \, \commabrack{u_\epsilon \;
              \mname{btimes} \; v_\epsilon} \, 0}}$.

    \item $(\mname{is-bnum} \, \syn{u_\epsilon} \And 
        \mname{is-bnum} \, \syn{v_\epsilon}) \Implies {}\\
        \hspace*{2ex} \syn{\syn{v_\epsilon} \; \mname{btimes} \;
          \synbrack{\mname{bnat} \, \commabrack{u_\epsilon} \, 1}} =
        \syn{\synbrack{\mname{bnat} \, \commabrack{u_\epsilon \;
              \mname{btimes} \; v_\epsilon} \, 0} \; \mname{badd} \;
          v_\epsilon}$.


  \ee

  \item[] \textbf{Transformers}

  \be

      \setcounter{enumi}{6}

    \item $\xi_7$ computes $\mname{btimes}_{\epsilon \tarrow \epsilon
      \tarrow \epsilon}$ using an efficient program that satisfies
      Axioms 20--27.

    \item $\xi_8$ computes $\mname{btimes}_{\epsilon \tarrow \epsilon
      \tarrow \epsilon}$ using Axioms 20--27 as conditional rewrite
      rules.

    \item $\xi_9$ computes $\mname{is-fo-T3}_{\epsilon \tarrow
      \epsilon}$ using an efficient program that accesses the data
      stored in the data structures that represent expressions.

    \item $\xi_{10}$ computes $\mname{is-fo-T3}_{\epsilon \tarrow
      \epsilon}$ using its definition.

  \ee

  \item[] \textbf{Theorems}

  \be

    \setcounter{enumi}{1}

    \item Meaning formula schema for
    $\mname{btimes}_{\epsilon \tarrow \epsilon \tarrow \epsilon}$

    $((\mname{is-bnum} \, \syn{\textbf{A}_\epsilon} \And 
      \mname{is-bnum} \, \syn{\textbf{B}_\epsilon}) 
      \Implies {}\\
      \hspace*{2ex}(\mname{is-bnum} \, 
      \syn{(\textbf{A}_\epsilon \; \mname{btimes} \; \textbf{B}_\epsilon)} \And {}\\
      \hspace*{2.8ex}(\sembrack{\syn{\textbf{A}_\epsilon \; \mname{btimes} \; 
      \textbf{B}_\epsilon}}_{\sf nat} = 
      \sembrack{\syn{\textbf{A}_\epsilon}}_{\sf nat} + 
      \sembrack{\syn{\textbf{B}_\epsilon}}_{\sf nat})))$.

  \ee

\ei

\noindent
\textbf{T4: Robinson Arithmetic (Q)}

\bi

  \item[] \textbf{Extended Theories} 

  \be

    \setcounter{enumi}{2}

    \item T3.

  \ee

  \item[] \textbf{Axioms}

  \be

    \setcounter{enumi}{27}

    \item $x_{\sf nat} = 0 \Or \ForsomeApp y_{\sf nat} \mdot S \,
      y_{\sf nat} = x_{\sf nat}$.

  \ee

\ei

\noindent
\textbf{T5: Complete Theory of Successor}

\bi

  \item[] \textbf{Extended Theories} 

  \be

    \setcounter{enumi}{0}

    \item T1.

  \ee

  \item[] \textbf{Primitive Constants}

  \be

    \setcounter{enumi}{6}

    \item $\mname{T5-dec-proc}_{\epsilon \tarrow \epsilon}$.

  \ee

  \item[] \textbf{Defined Constants}

  \be

    \setcounter{enumi}{5}

    \item $\mname{is-fo-T1-abs}_{\epsilon \tarrow \epsilon} = {}\\
    \hspace*{2ex}\LambdaApp \syn{x_\epsilon} \mdot 
    (\If \; (\mname{is-abs}_{\epsilon \tarrow o} \, \syn{x_\epsilon}) \;
    \syn{(\mname{is-fo-T1}_{\epsilon \tarrow \epsilon} \,
    (\mname{abs-body}_{\epsilon \tarrow \epsilon} \, x_\epsilon))} \;
    \syn{\synbrack{F_o}})$.

  \ee

  \item[] \textbf{Axioms}

  \be

    \setcounter{enumi}{28}

    \item Induction Schema for Successor

    $\ForallApp \syn{f_\epsilon} \mdot 
    ((\mname{is-expr}_{\epsilon \tarrow o}^{{\sf nat} \tarrow o} \, \syn{f_\epsilon} \And
    \sembrack{\syn{\mname{is-fo-T1-abs}_{\epsilon \tarrow \epsilon} \, 
    f_\epsilon}}_o) \Implies {} \\
    \hspace*{2ex}((\sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, 0 \And
    (\ForallApp x_{\sf nat} \mdot 
    \sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, x_{\sf nat} \Implies
    \sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, 
    (\mname{S} \, x_{\sf nat}))) \Implies 
    \hspace*{2.8ex}\ForallApp x_{\sf nat} \mdot 
    \sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, x_{\sf nat}))$.

    \item Meaning Formula for $\mname{T5-dec-proc}_{\epsilon \tarrow \epsilon}$

    $\ForallApp \syn{u_\epsilon} \mdot 
     ((\mname{is-expr}_{\epsilon \tarrow o}^{o} \, 
     \syn{u_\epsilon} \And
     \mname{is-closed}_{\epsilon \tarrow o} \, \syn{u_\epsilon} \And 
     \sembrack{\syn{\mname{is-fo-T1}_{\epsilon \tarrow \epsilon} \, 
     u_\epsilon}}_o) \Implies {}\\
     \hspace*{2ex}((\syn{\mname{T5-dec-proc}_{\epsilon \tarrow \epsilon} \, u_\epsilon} = 
     \syn{\synbrack{T_o}} \Or 
     \syn{\mname{T5-dec-proc}_{\epsilon \tarrow \epsilon} \, u_\epsilon} = 
     \syn{\synbrack{F_o}}) \And {}\\
     \hspace*{3.1ex}
     \sembrack{\syn{\mname{T5-dec-proc}_{\epsilon \tarrow \epsilon} \, u_\epsilon}}_o =
     \sembrack{\syn{u_\epsilon}}_o))$.

  \ee

  \item[] \textbf{Transformers}

  \be

    \setcounter{enumi}{10}

    \item $\xi_{11}$ computes the decision procedure
      $\mname{T5-dec-proc}_{\epsilon \tarrow \epsilon \tarrow
      \epsilon}$ using an efficient program that satisfies
      Axiom 30.


    \item $\xi_{12}$ computes $\mname{is-fo-T1-abs}_{\epsilon \tarrow
      \epsilon}$ using an efficient program that accesses the data
      stored in the data structures that represent expressions.

    \item $\xi_{13}$ computes $\mname{is-fo-T1-abs}_{\epsilon \tarrow
      \epsilon}$ using its definition.

  \ee

\ei

\noindent
\textbf{T6: Presburger Arithmetic}

\bi

  \item[] \textbf{Extended Theories} 

  \be

    \setcounter{enumi}{1}

    \item T2.

  \ee
    
  \item[] \textbf{Primitive Constants}

  \be

    \setcounter{enumi}{7}

    \item $\mname{T6-dec-proc}_{\epsilon \tarrow \epsilon}$.

  \ee

  \item[] \textbf{Defined Constants}

  \be

    \setcounter{enumi}{6}

    \item $\mname{is-fo-T2-abs}_{\epsilon \tarrow \epsilon} = {}\\
    \hspace*{2ex}\LambdaApp \syn{x_\epsilon} \mdot 
    (\If \; (\mname{is-abs}_{\epsilon \tarrow o} \, \syn{x_\epsilon}) \;
    \syn{(\mname{is-fo-T2}_{\epsilon \tarrow \epsilon} \,
    (\mname{abs-body}_{\epsilon \tarrow \epsilon} \, x_\epsilon))} \;
    \syn{\synbrack{F_o}})$.

  \ee

  \item[] \textbf{Axioms}

  \be

    \setcounter{enumi}{30}

    \item Induction Schema for Successor and Addition

    $\ForallApp \syn{f_\epsilon} \mdot 
    ((\mname{is-expr}_{\epsilon \tarrow o}^{{\sf nat} \tarrow o} \, \syn{f_\epsilon} \And
    \sembrack{\syn{\mname{is-fo-T2-abs}_{\epsilon \tarrow \epsilon} \, 
    f_\epsilon}}_o) \Implies {} \\
    \hspace*{2ex}((\sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, 0 \And
    (\ForallApp x_{\sf nat} \mdot 
    \sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, x_{\sf nat} \Implies
    \sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, 
    (\mname{S} \, x_{\sf nat}))) \Implies 
    \hspace*{2.8ex}\ForallApp x_{\sf nat} \mdot 
    \sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, x_{\sf nat}))$.

    \item Meaning formula for $\mname{T6-dec-proc}_{\epsilon \tarrow \epsilon}$.


    $\ForallApp \syn{u_\epsilon} \mdot 
    ((\mname{is-expr}_{\epsilon \tarrow o}^{o} \, 
    \syn{u_\epsilon}  \And
    \mname{is-closed}_{\epsilon \tarrow o} \, \syn{u_\epsilon} \And 
    \sembrack{\syn{\mname{is-fo-T2}_{\epsilon \tarrow \epsilon} \, 
    u_\epsilon}}_o) \Implies {}\\
    \hspace*{2ex}((\syn{\mname{T6-dec-proc}_{\epsilon \tarrow \epsilon} \, u_\epsilon} = 
    \syn{\synbrack{T_o}} \Or 
    \syn{\mname{T6-dec-proc}_{\epsilon \tarrow \epsilon} \, u_\epsilon} = 
    \syn{\synbrack{F_o}}) \And {}\\
    \hspace*{3.1ex}
    \sembrack{\syn{\mname{T6-dec-proc}_{\epsilon \tarrow \epsilon} \, u_\epsilon}}_o =
    \sembrack{\syn{u_\epsilon}}_o))$.

  \ee

  \item[] \textbf{Transformers}

  \be

    \setcounter{enumi}{13}

    \item $\xi_{14}$ computes the decision procedure
      $\mname{T6-dec-proc}_{\epsilon \tarrow \epsilon \tarrow
      \epsilon}$ using an efficient program that satisfies
      Axiom 32.


    \item $\xi_{15}$ computes $\mname{is-fo-T2-abs}_{\epsilon \tarrow
      \epsilon}$ using an efficient program that accesses the data
      stored in the data structures that represent expressions.

    \item $\xi_{16}$ computes $\mname{is-fo-T2-abs}_{\epsilon \tarrow
      \epsilon}$ using its definition.

  \ee
    
  \item[] \textbf{Theorems}

    \be

      \setcounter{enumi}{2}

      \item Meaning formula for 
      $\mname{bplus}_{\epsilon \tarrow \epsilon \tarrow \epsilon}$

      $\ForallApp \syn{u_\epsilon} \mdot \ForallApp \syn{v_\epsilon} \mdot
      ((\mname{is-bnum} \, \syn{u_\epsilon} \And \mname{is-bnum} \, \syn{v_\epsilon}) 
      \Implies {}\\
      \hspace*{2ex}(\mname{is-bnum} \, 
      \syn{(u_\epsilon \; \mname{bplus} \; v_\epsilon)} \And {}\\
      \hspace*{2.8ex}(\sembrack{\syn{u_\epsilon \; \mname{bplus} \; 
      v_\epsilon}}_{\sf nat} = 
      \sembrack{\syn{u_\epsilon}}_{\sf nat} + \sembrack{\syn{v_\epsilon}}_{\sf nat})))$.

    \ee

\ei

\noindent
\textbf{T7: First-Order Peano Arithmetic}

\bi

  \item[] \textbf{Extended Theories} 

  \be

    \setcounter{enumi}{2}

    \item T3.

  \ee

  \item[] \textbf{Defined Constants}

  \be

    \setcounter{enumi}{7}

    \item $\mname{is-fo-T3-abs}_{\epsilon \tarrow \epsilon} = {}\\
    \hspace*{2ex}\LambdaApp \syn{x_\epsilon} \mdot 
    (\If \; (\mname{is-abs}_{\epsilon \tarrow o} \, \syn{x_\epsilon}) \;
    \syn{(\mname{is-fo-T3}_{\epsilon \tarrow \epsilon} \,
    (\mname{abs-body}_{\epsilon \tarrow \epsilon} \, x_\epsilon))} \;
    \syn{\synbrack{F_o}})$.

  \ee

  \item[] \textbf{Axioms}

  \be

    \setcounter{enumi}{32}

    \item Induction Schema for Successor, Addition, and Multiplication

    $\ForallApp \syn{f_\epsilon} \mdot 
    ((\mname{is-expr}_{\epsilon \tarrow o}^{{\sf nat} \tarrow o} \, \syn{f_\epsilon} \And
    \sembrack{\syn{\mname{is-fo-T3-abs}_{\epsilon \tarrow \epsilon} \, 
    f_\epsilon}}_o) \Implies {} \\
    \hspace*{2ex}((\sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, 0 \And
    (\ForallApp x_{\sf nat} \mdot 
    \sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, x_{\sf nat} \Implies
    \sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, 
    (\mname{S} \, x_{\sf nat}))) \Implies 
    \hspace*{2.8ex}\ForallApp x_{\sf nat} \mdot 
    \sembrack{\syn{f_\epsilon}}_{{\sf nat} \tarrow o} \, x_{\sf nat}))$.

  \ee

  \item[] \textbf{Transformers}

  \be

    \setcounter{enumi}{16}

    \item $\xi_{17}$ computes $\mname{is-fo-T3-abs}_{\epsilon \tarrow
      \epsilon}$ using an efficient program that accesses the data
      stored in the data structures that represent expressions.

    \item $\xi_{18}$ computes $\mname{is-fo-T3-abs}_{\epsilon \tarrow
      \epsilon}$ using its definition.

  \ee

  \item[] \textbf{Theorems}

  \be

    \setcounter{enumi}{3}

    \item Meaning formula
    $\mname{btimes}_{\epsilon \tarrow \epsilon \tarrow \epsilon}$

    $\ForallApp \syn{u_\epsilon} \mdot \ForallApp \syn{v_\epsilon} \mdot
    ((\mname{is-bnum} \, \syn{u_\epsilon} \And \mname{is-bnum} \, \syn{v_\epsilon}) 
    \Implies {}\\
    \hspace*{2ex}(\mname{is-bnum} \, 
    \syn{(u_\epsilon \; \mname{btimes} \; v_\epsilon)} \And {}\\
    \hspace*{2.8ex}(\sembrack{\syn{u_\epsilon \; \mname{btimes} \; 
    v_\epsilon}}_{\sf nat} = 
    \sembrack{\syn{u_\epsilon}}_{\sf nat} * \sembrack{\syn{v_\epsilon}}_{\sf nat})))$.

  \ee

\ei

\noindent
\textbf{T8: Higher-Order Peano Arithmetic}

\bi

  \item[] \textbf{Extended Theories} 

  \be

    \setcounter{enumi}{0}

    \item T1.

  \ee

  \item[] \textbf{Defined Constants}

  \be

    \setcounter{enumi}{8}

    \item $+_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}} =
    \IotaApp f_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}} \mdot
    \ForallApp x_{\sf nat} \mdot \ForallApp y_{\sf nat} \mdot {}\\
    \hspace*{2ex} (f_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}} \, 
    x_{\sf nat} \, 0 = x_{\sf nat} \And {}\\
    \hspace*{2.8ex}f_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}} \, 
    x_{\sf nat} \, (S \, y_{\sf nat}) = S \, 
    (f_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}} \, x_{\sf nat} \,
    y_{\sf nat}))$.

    \item $*_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}} =
    \IotaApp f_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}} \mdot
    \ForallApp x_{\sf nat} \mdot \ForallApp y_{\sf nat} \mdot {}\\
    \hspace*{2ex} (f_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}} \, 
    x_{\sf nat} \, 0 = 0 \And {}\\
    \hspace*{2.8ex}f_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}} \, 
    x_{\sf nat} \, (S \, y_{\sf nat}) =  
    (f_{{\sf nat} \tarrow {\sf nat} \tarrow {\sf nat}} \, x_{\sf nat} \,
    y_{\sf nat}) + x_{\sf nat})$.

  \ee



  \item[] \textbf{Axioms}

  \be

    \setcounter{enumi}{33}

    \item Induction Axiom for the Natural Numbers

    $\ForallApp p_{{\sf nat} \tarrow o} \mdot ((p_{{\sf nat} \tarrow o} \, 0 \And 
    (\ForallApp x_{\sf nat} \mdot (p_{{\sf nat} \tarrow o} \, x_{\sf nat} \Implies 
    p_{{\sf nat} \tarrow o} \, (S \, x_{\sf nat})))) \Implies {}\\
    \hspace*{2ex}\ForallApp x_{\sf nat} \mdot 
    p_{{\sf nat} \tarrow o} \, x_{\sf nat})$.

  \ee

  \item[] \textbf{Theorems}

  \be

    \setcounter{enumi}{4}

    \item Induction Schema for Successor.

    \item Induction Schema for Successor and Addition.

    \item Induction Schema for Successor, Addition, and Multiplication.

  \ee

\ei

\bibliography{imps}
\bibliographystyle{plain}

\end{document}

